[{"title":"ColorMaster 第一个lua项目","url":"/2025/06/19/ColorMaster%20%E7%AC%AC%E4%B8%80%E4%B8%AAlua%E9%A1%B9%E7%9B%AE/","content":"在 _Arahc_ 的游说下，自学了 lua 语言，并依据下午刚得来的灵感，创作了第一个样例小游戏：ColorMaster ！  \n仓库链接: ColorMaster: my first lua project   \n在这里记录下lua语言的学习与配置过程，以及建立项目的全流程。\nlua语言\nlua语言\n\nlua是基于C语言开发的轻量级解释执行的编程语言，语法学习曲线极为平坦，体感极为舒适 (乐不思C, C++, python) ，而且性能继承自C语言，比python高效。\n\n\n配置环境\n\n我的环境是 Windows + VSCode，我先是从网站上下载了lua的源代码，再根据 教程 一步步安装。\n安装好后，不要忘记配置环境变量！\nVSCode 有现成的lua插件 Lua (sumneko) 和 Lua (Tencent). 安装后编辑器即可检查语法错误。\n\n\n\nLove2d 库 (LÖVE)\nLÖVE\n\n这是一个专为lua语言开发的2d游戏开发框架，兼具跨平台、轻量级等优势。\n\n\n下载与配置\n\n访问 LÖVE官网 下载最新版本，安装至任意目录下，并添加到环境变量即可使用。\n\n\n运行代码\n\n在VSCode中打开终端，并跳转至代码根目录下；\n输入指令 love . 即可运行当前目录下的 main.lua 文件（文件名不可修改）。\n\n\n打包为可执行文件\n\n在VSCode中打开终端，并跳转至代码根目录下；\n\n将LÖVE安装目录中的 love.exe 文件复制进代码根目录；\n\n在终端中依次输入：\nzip -r mygame.love .cmd /c &quot;copy /b love.exe+mygame.love mygame.exe&quot;\n\n这样得到的就是独立的 .exe 文件了！\n\n\n\n\nColorMaster灵感来源于配色时口胡十六进制色号。这个小游戏给出会给出一个色块，并让你输入颜色对应的色号。输入后，游戏会计算并输出你的分数。练习口胡色号的技巧！  \n仓库链接再放送: ColorMaster: my first lua project \n","tags":["Projects"]},{"title":"Add_BGM","url":"/2025/05/19/Add_BGM/","content":"向主页添加了第一首歌，然后又添加了4首。  \n记录一下操作：  \n\n打开 aaaaa_online\\_config.redefine.yml 找到 plugins/aplayer/audios ，复制一份如下代码：  \n\nartist: 葉月ゆら # audio artist\nurl: /music/HAMELN.mp3 # audio url\ncover: /images/cover/HAMELN.png # audio cover url\nlrc: # audio cover lrc\n\n\n\n\n更改作者、曲名；  \n\n在 aaaaa_online\\node_modules\\hexo-theme-redefine\\source\\music 目录下保存一份 mp3 ，在 aaaaa_online\\node_modules\\hexo-theme-redefine\\source\\images\\cover 目录下保存一份背景图；  \n\n上传！\n\n\n这个播放器插件声音有点大，而且没办法调节声音大小，略显不方便。以后找机会换一个能调声音大小的。\n","tags":["Website_building"]},{"title":"Make Friends","url":"/2025/05/19/Make%20Friends/","content":"添加了友链功能。  \n记录一下操作：  \n\n打开 aaaaa_online\\source\\_data\\links.yml ，添加以下内容：  \n\n - name:  # Name\n   link:  # Friend&#39;s link\n   description:  # Individual signiture\n   avatar:  # Photo\n\n\n\n\n编辑姓名、友链、个签、头像；  \n\n上传！\n\n\n","tags":["Website_building"]},{"title":"Musician更新：支持Linux风格指令集","url":"/2025/05/26/Musician%E6%9B%B4%E6%96%B0%EF%BC%9A%E6%94%AF%E6%8C%81Linux%E9%A3%8E%E6%A0%BC%E6%8C%87%E4%BB%A4%E9%9B%86/","content":"仓库:  aaaaa114514-1&#x2F;musician: An individual music player with a little bit more functions.   \nMusician 迎来了上线以来的第一次更新！  \n\n更新了 Linux 风格的指令集  \n增加了默认曲库配置，让初次使用更加快捷\n\n今后，可以使用 :q :? 等熟悉的指令来快捷操作 Musician 啦！\n","tags":["Projects"]},{"title":"Musician音乐播放器","url":"/2025/05/21/Musician%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/","content":"仓库放开头:  aaaaa114514-1&#x2F;musician: An individual music player with a little bit more functions. \n听音乐是个不错的爱好。  \n但是，一放音乐就卡的Windows自带播放器体感极度不舒适；mediaPlayer虽然可以播放音乐，但是它的UI风格实在有点年代感，用着也不太习惯。  \n恰好，一年前，在学习网络爬虫的时候，我用python写了个酷狗音乐的爬虫，25年年初的时候翻出来测试，发现已经跟不上版本了；恰好，我在群里听说，网易云的本地文件加密是用的按位 ^163 的方法。  \n于是，在2025年3月，我决定用python写一个小型Project，用命令行写一个播放器，集成酷狗和网易云下载工具，以解决自己的播放器问题。  \n不到一个礼拜，代码的主要部分就完工了。后来在使用过程中陆续发现了一些bug，顺便开发了一些必要的功能，比如说一开始没做的“上一曲”（不知道我当时为什么没设计这么重要的功能），为了睡眠质量而开发的“定时关闭”，以及后来加上的“数据统计 history”等等。  \n现在，这个项目已经初具雏形，虽然离趋于完善还有很长的路，不过可以先分享出来，一边接受反馈，一边修改。  \n仓库是今天新建的，先写了英文版的README，后来又加了中文版。略微修改了原来程序的接口，使得移植更加方便了。中文版的README一同贴出来：  \n注意：此处的README不实时更新，具体请以仓库中的为准！  \nMusician一个拥有曲库管理功能的命令行音乐播放器代码 aaaaa\nMusician 是一个命令行控制的音乐播放器，专为程序员音乐爱好者设计，支持：\n\n听歌\n从酷狗音乐或网易云音乐免费下载歌曲\n建立个人曲库\n记录播放历史\n\n程序使用 Python 编写，播放功能基于 pygame。由于作者编程水平有限，可能存在一些 Bug——欢迎反馈，我会尽力修复！\n\n程序概览musician 目录包含以下文件：\nmusician/├── history.txt        # 播放历史记录  ├── Icon.ico           # 程序图标  ├── musician.exe       # 可执行文件（用户使用）  ├── musician.py        # 源代码（开发者查看）  ├── README.md          # 说明文档  └── savedata.txt       # 配置文件  \n\n\n用户：修改 savedata.txt（仅首次配置），然后运行 musician.exe。\n开发者：可查看 musician.py 和 savedata.txt。\n\n\n用户指南1. 配置 savedata.txt该文件定义了路径和设置：\nC:\\Users\\Netease\\CloudMusic\\Cache\\Cache   # 网易云音乐缓存路径  D:\\BGM\\Download&amp;Decode                    # 下载/解码目录  D:\\BGM\\Download&amp;Decode\\temp               # 临时文件存放  D:\\BGM\\Lis                                # 播放列表文件夹  D:\\BGM                                    # 主音乐库  0.4                                       # 默认音量（0–1）  30                                        # 搜索匹配阈值（%）  1d4e5b7decbe434048e596ae2d597adb          # 酷狗 token（后32位）  D:\\BGM\\Settings\\history.txt               # 历史记录文件路径  \n\n配置步骤\n网易云缓存路径\n\n打开 网易云音乐桌面端 → 设置 → 下载 → 复制缓存路径。\n在路径末尾手动添加 \\Cache（如 C:\\...\\Cache\\Cache）。\n\n\n音乐库文件夹创建以下目录（示例名称）：\nBGM/  ├── Download&amp;Decode/  # 用于下载/解码  │   └── temp/         # 临时文件  └── Lis/              # 播放列表存放  \n\n将它们的路径填入 savedata.txt 的第 2–5 行。\n\n酷狗 Token（可选）\n\n登录 酷狗音乐官网。\n播放任意歌曲 → 按 F12 打开开发者工具 → Network（网络） 标签。\n找到 https://wwwapi.kugou.com/play/songinfo? 的请求。\n复制 token 参数的最后32位字符，即在...5e6de之后的部分（如 55f2409f72970daa21bdc63acee305db）。\n粘贴到 savedata.txt 第 8 行。\n如果不需要使用酷狗下载音乐，可跳过此步。\n\n\n历史记录文件指定 history.txt 的路径（第 9 行）并将给出的 history.txt 文件移到指定路径下，程序会自动管理该文件。\n\n\n\n2. 命令速查在 &gt;&gt; 后输入命令（不区分大小写）。\n基础操作\n\n\n命令\n功能\n\n\n\nquit&#x2F;exit&#x2F;end\n退出程序（尽可能不要用右上角的×退出程序）。\n\n\nhelp\n显示所有命令。\n\n\n网易云音乐\n\n\n命令\n功能\n\n\n\ncheck163\n列出缓存歌曲（若报错，请检查网络连接）。\n\n\ndecode &lt;编号&gt;\n解码歌曲（如 decode 3 或 decode 2 5-9 4）。\n\n\nclear163\n清空缓存（先关闭网易云桌面端！）。\n\n\n酷狗音乐\n\n\n命令\n功能\n\n\n\nsearch &lt;歌名&gt;\n搜索（如 search 夏の紫苑）。\n\n\ndownload &lt;编号&gt;\n下载（VIP 歌曲需先登录酷狗VIP账号）。\n\n\n播放控制\n\n\n命令\n功能\n\n\n\nplay&#x2F;pause\n播放&#x2F;暂停。\n\n\nplay &lt;编号&gt;\n播放指定歌曲（如 play 1-3 5）。\n\n\nadd &lt;编号&gt;\n添加到播放列表。\n\n\nmode &lt;single/cycle/random&gt;\n设置播放模式（单曲循环&#x2F;列表循环&#x2F;随机）。\n\n\nstop\n停止播放。\n\n\nlast&#x2F;previous\n上一首。\n\n\nnext\n下一首。\n\n\nrestart&#x2F;replay\n重新播放当前歌曲。\n\n\nvolume &lt;数值&gt;\n调整音量（0–100%，如 volume 40）。\n\n\n音乐库 &amp; 历史\n\n\n命令\n功能\n\n\n\nsavelist\n显示已下载歌曲。\n\n\nsave &lt;Lis/BGM&gt;\n将歌曲移至 Lis（播放列表）与 BGM（音乐库）&#x2F;仅移至BGM。\n\n\nclear\n清空下载列表。\n\n\nlibrary\n浏览音乐库。\n\n\nlookup &lt;歌名&gt;\n搜索音乐库。\n\n\ntimelimit &lt;分钟&gt;\n设置最长播放时间（如 timelimit 45）。\n\n\nhistory\n查看播放历史。\n\n\n?\n显示当前播放的歌曲。\n\n\n\n曲库以mp3格式为默认存储格式，其他格式的音频将无法播放。你可以将原本的个人曲库直接迁移到 BGM 和 Lis 列表下。\n请务必在 BGM 和 Lis 列表下分别存放至少1个mp3文件，否则曲库会崩溃！ \n\n开发者说明\n先阅读用户指南了解功能逻辑。\n查看 musician.py——代码应该还算易懂（大概）。😊\n在终端用指令 pyinstaller --onefile musician.py -i Icon.ico 来将 .py 文件打包成 .exe 文件。\n\n\n祝你在 Musician 的陪伴下享受音乐！ 🎵\n","tags":["Projects"]},{"title":"The_First_Step","url":"/2025/05/17/The_First_Step/","content":"个人网页终于建出来了！感谢 Arahc 的帮助！  \n友情链接：  Arahc’s Home - A simple blog site.  \n时间不早了，今天测完网页就睡。  \n记录一下操作：  \n\n$ hexo clean 清除generate的内容;\n$ hexo g generate: 生成基于新的内容的 bulider;  \n$ hexo s server: 开启本地服务器，用于测试;  \n(默认在 http://localhost:4000/ 打开本地测试)\n\n\n$ hexo d deploy: 部署到网页，发布到公网。\n\n在 Github仓库 可以看到上传的内容与上传的进度。由于上传很慢，所以要本地测试后再上传。  \n","tags":["Website_building"]},{"title":"Photor：轻量级图片加密查看工具","url":"/2025/10/10/Photor%EF%BC%9A%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%9B%BE%E7%89%87%E5%8A%A0%E5%AF%86%E6%9F%A5%E7%9C%8B%E5%B7%A5%E5%85%B7/","content":"仓库放开头：aaaaa114514-1&#x2F;Photor: A light photo viewer   \n每个人电脑里都可能有一些隐私的照片，而在文件交换需求日益增长的今天，偶尔的发错文件又是难以避免的事情。  \n那么，我们有没有办法避免隐私照片泄露呢？  \n有的兄弟，有的。  \nPhotor 是一款轻量级图片加密查看工具，支持高效的加密功能，同时支持自定义翻页键位。 \n整个工具分为3个可执行文件： aaaLocker.exe aaaViewer.exe aaaSetUp.exe :\n\n每次加密时，只需将 aaaLocker.exe 复制入你需要加密的根目录，并把它重命名为 加密密码.exe ，双击即可一键加密根目录及各级子目录下的所有图片文件；  \n\n每次打开文件时，只需运行 aaaSetUp.exe 并输入密码， aaaViewer.exe 即可加载好查看图片的密码，此时双击加密的图片，用 aaaViewer.exe 打开即可查看；\n\n上一次的输入的查看密码会自动记忆，不必重复输入\naaaSetUp.exe 还有修改键位的功能，当然也可以重置键位\n\n\n\n重要注意事项：加密过程暂为不可逆过程（解密器将在后续补全），注意在加密之前将图片手动备份！  \n\n在这次 Photor 项目中，我首次尝试了用 iss 代码（Inno，一款非商用的安装包配置工具）来配置安装包，在 LLM 的帮助下完成了多个可执行文件的安装包配置。现在，即使是我的小工具，也可以有市面上软件类似的安装包界面了！帅！  \n这次项目的 github 仓库里，我特地学习了一般项目的 github 仓库格式，尽可能规范化地建立文件夹和仓库文件，并把安装包放进了 release 里。这样，开发者和用户就能够快速地各取所需了。  \n项目编写时间不长，但是正好遇上换新电脑，直到开始上传 github 才想起来 github 的 F2A 和 recovery_code 都在几百公里外、已经关机的旧电脑上，网页端 github 根本登不上去。还好有 github desktop ，我还可以正常 git 仓库。  \n写这篇帖子时，我发现新电脑上还没有个人网页的上传本地仓库。回去又得迁移文件了。\n\nPhotor 项目还会持续更新，未来可能会支持更多功能，进一步优化用户体验。敬请期待！\n","tags":["Projects"]},{"title":"从零开始的Shadertoy生活_00","url":"/2025/06/30/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Shadertoy%E7%94%9F%E6%B4%BB_00/","content":"从零开始的Shadertoy生活目录00 目录与序01 Shadertoy与glsl语言序2025暑学期，挤破头选到一门像素着色艺术，上了几节课，感觉确实很有意思，不过Workload比较大。  \n但是，大Workload × Coding × 兴趣型选手 &#x3D; A  \n像素着色艺术布置了一个可选的hw0，是专门设计给有Project想法的同学的，算额外加分。刚好我有Idea，箭在弦上，不得不发，一发不可收拾。一不小心一口气写完后意犹未尽，回望来时的路，也就是和Shadertoy的这一段共处时间，不禁想要写一段Shadertoy的入门教程，一方面方便自己随时回来复习，另一方面也大力传教种草，方便Shader后浪推前浪。此系列不定期更新，争取更完 成为我网站完结的第一个系列。  \n考虑到篇幅原因，本系列将默认读者有一定的C语言基础，并对计算机结构有极为基本的了解。至于兴趣，我是在逐渐熟悉Shadertoy的过程中产生的，相信读者也会同样感受到创造过程中强烈的正反馈。\n参考资料\nThe Book of Shaders 这个系列写得非常好，适合入门，可惜没更完。  \n\nShader 中文教程 非常全面的教程，推荐学习。  \n\nThe OpenGL® Shading Language, Version 4.60.8 截至2025.7，这是最新版的glsl语言标准。\n\n\n特别鸣谢\nArahc  Arahc’s Home - A simple blog site.   Arahc - Shadertoy BETA\n\nDrHow  DrHow - Shadertoy BETA  ARTS1308 - Shadertoy BETA\n\n\n","tags":["Shadertoy"]},{"title":"从零开始的Shadertoy生活_01","url":"/2025/06/30/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Shadertoy%E7%94%9F%E6%B4%BB_01/","content":"01 Shadertoy 与 glsl 语言我们从 Shadertoy 和 glsl 语言 开始谈起。  \nShadertoyShadertoy 是一个支持编译glsl语言的在线编译器，同时也是一个交流shader（中文翻译：着色器）的黑客社区。这里的学术风气很友好，有不停贡献的萌新，也有热心讲解的大佬。（不过没人来评价我的作品，是太简单了吗）打个广告，欢迎来关注我：aaaaa114514   \nShadertoy 社区评判好作品的标准有：画的好看&#x2F;仿真，短代码配惊艳效果。由于只用GPU而不用CPU内存的特性，glsl语言有极其惊艳的压缩能力，可以将几分钟的视频压缩到几kb（几乎全是代码）。因此，很多系统或游戏的开场界面会使用闲置的GPU来运行Shader，渲染好看的微动画商标。  \nglsl 语言配置环境glsl语言配置环境非常轻松，在这里介绍两种方法：  \n\n访问 Shadertoy ，点击右上角的“新建”按钮，写完代码后点击代码区左下角三角形按钮即可编译，然后在左侧的预览框中看到运行效果。\n使用 VSCode。安装插件 Shader Toy (by Adam Stevenson) 和 Shader language support for VS Code (by slevesque) 并重启VSCode，然后新建一个后缀名 .glsl 的文件即可。需要注意的是，编译时需要右键代码区，点击 Shader Toy: Show GLSL Preview 或 Shader Toy: Show Static GLSL Preview 选项（据说区别是后者不再动态响应代码修改或者键鼠输入，但是实测并没有区别），即可在屏幕右侧或下侧看到运行效果。\n\nglsl语言与C语言glsl语言是一种C语言的变体，继承了很多C的特性，但是你想要的C的好用功能，glsl几乎都没有。当然，这得从glsl完全脱离内存讲起（这是主线，非常重要）。众所周知，GPU是一堆擅长线性计算的小学生，也就是擅长多次相似的并行计算，而非少量复杂的计算。因此，glsl语言的程序核心，对应C语言里的主函数main，格式如下：  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )&#123;    // Normalized pixel coordinates (from 0 to 1)    vec2 uv = fragCoord/iResolution.xy;    // Time varying pixel color    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));    // Output to screen    fragColor = vec4(col,1.0);&#125;\n\n如上代码其实是Shadertoy官网上新建Shader后的示例代码。主函数 mainImage 固定输出 (注意是输出out, 而非返回return) 一个四维数组fragColor表示颜色，读入一个fragCoord表示坐标。“像素着色艺术”这个名字起得名副其实，正如主函数输入像素（坐标），输出颜色，你写代码的部分就是着色的过程，产出的就是艺术（能不能欣赏得来见仁见智）。\n回到主线，正因为glsl语言不使用内存而只用显存，所以这个主函数会被每个GPU单元、每一帧运行一次，输出的结果会先存在进程的私有寄存器内，然后等待所有线程结束后，统一将每个线程输出的fragColor存入显存里的帧缓冲区的二维数组中，最后统一传给显示器，或者参与下一帧的计算。\n因为没有内存，所以glsl语言里没有C语言的类class（只有struct，但是是C语言的类，不支持成员函数，另外不支持结构体数组）、地址操作（指针、取地址、解引用，申请内存，引用传参等）、输入输出操作（input&#x2F;printf等）、几乎所有隐式转换（包括任意类型向bool的转换、int和float的转换等），更没有stdio.h&#x2F;stdlib.h中的绝大多数函数，C++的库更是无需多言。另外，glsl语言还不支持全局变量（const可以，详情见后）、读取前一帧Image内容（Buffer可以，详情见后）和所有非确定运行次数的代码（如while(1)-break结构、递归调用、动态大小数组等）。现在知道C语言的方便之处了吧  \n注：需要注意的是，在不同系统、不同环境中运行glsl语言的代码，可能会产生不同的结果。甚至，连glsl语言本身都有好多套不同的标准，这背后有资本的力量。有些良心系统上支持while(1)-break等结构，但是这并不是符合所有标准的，因此还是要尽可能避免使用。  \n听起来是不是极其不方便？确实，glsl上手有一定难度。不过当你逐渐熟悉这些限制之后，你会发现这门语言运行效率之高，领略GPU带来的CPU无法取代的并行计算效率，逐渐被这门语言的可视化艺术和各路高手各显神通创造的神作所折服。  \n差点忘记说了，glsl语言也有自己的语法糖，用起来还算方便。 （还没有从C里面删掉的多） \n\n示例代码中的 vec2 和 vec4 就是glsl的原生数组，一共有三种: vec2&#x2F;vec3&#x2F;vec4 ，每种都默认是float数组，还有变体int数组 ivec3 ，无符号整型数组 uvec4 和bool数组 bvec2 各三种。这些数组支持比较方便的构造和访问、修改和运算操作，样例如下：\n// 构造//// 1. 直接赋值vec2 uv = vec2(0.5, 0.5);vec3 color = vec3(0.7, 0.4, 0.2);// 2. 单值填充vec3 gray = vec3(0.5); // 等效于 (0.5, 0.5, 0.5)// 3. 混合构造vec4 transparentRed = vec4(vec3(1.0, 0.0, 0.0), 0.5); // RGB + Alphavec4 rgba = vec4(color, 1.0); // 扩展为 RGBA (等效于vec4(0.7, 0.4, 0.2, 1.0))\n\n// 访问和修改//vec4 pos = vec4(1.0, 2.0, 3.0, 4.0);  // 1. 标准下标（类似C数组）float x = pos[0]; // x = 1.0  // 2. 分量别名（支持 .xyzw / .rgba / .stpq ，但不可混用）float y = pos.y;   // y = 2.0float a = pos.a;   // Alpha = 4.0float t = pos.t;   // 纹理坐标 t = 2.0（与 .y 相同）  // 3. 链式访问（Swizzling）vec2 xy = pos.xy;  // 提取前两维 (1.0, 2.0)vec3 pos_bgr = pos.bgr; // 反转RGB通道 (3.0, 2.0, 1.0)vec4 pos_rara = pos.rara; // 允许重复提取 (1.0, 4.0, 1.0, 4.0)pos.wx = vec2(5.0, 6.0); // 修改 pos = (6.0, 2.0, 3.0, 5.0)\n\n// 运算//vec3 a = vec3(1.0, 2.0, 3.0);vec3 b = vec3(0.1, 0.2, 0.3);  // 1. 逐分量运算vec3 c = a + b;    // (1.1, 2.2, 3.3)vec3 d = a * 2.0;  // 标量乘法 (2.0, 4.0, 6.0)vec3 e = a + 3.0;  // 3.0被隐式转换为 vec3(3.0), 运算结果为 (4.0, 5.0, 6.0)float dotProduct = dot(a, b); // 点积vec3 crossProduct = cross(a, b); // 叉乘  // 2. 比较运算bvec3 isGreater = greaterThan(a, b); // (true, true, true)bool isEqual = (a == b); // false\n\nglsl语言有原生矩阵 mat2 mat3 mat4 ，还有 mat2x3 等非方阵：  \n// 定义//mat2 m2 = mat2(1.0, 2.0,   // 第一 列!!               3.0, 4.0);  // 第二 列!!// 以上代码画出了矩阵：// [1.0, 3.0]// [2.0, 4.0]// 这是符合数学直觉的，但是有点反人类// n个n维向量填充定义vec3 col0 = vec3(1.0, 2.0, 3.0); // 第一列vec3 col1 = vec3(4.0, 5.0, 6.0); // 第二列vec3 col2 = vec3(7.0, 8.0, 9.0); // 第三列mat3 m3 = mat3(col0, col1, col2); // 3x3 矩阵// 也可以向量-标量混合定义mat2 m4 = mat2(1.0, 2.0,  // 第一列 (1.0, 2.0)              vec2(3.0)); // 第二列 (3.0, 0.0)// 但不可以这样！vec2 a = vec2(1.0, 2.0);vec2 b = vec2(3.0, 4.0);vec2 c = vec2(5.0, 6.0);vec3 d = vec3(7.0, 8.0, 9.0);mat3 m = mat3(a, b, c, d); // 编译错误！参数不匹配\n\n// 矩阵与矩阵运算//// 矩阵之间的加、减、乘都符合数学规则，数乘同样符合规则mat2 m = mat2(1.0, 2.0, 3.0, 4.0);mat2 mInv = inverse(m); // 逆矩阵float det = determinant(m); // 行列式 = -2.0mat2 mT = transpose(m); // 矩阵的转置\n\n// 矩阵与向量乘法//mat4 model = mat4(2.0);  // 这是左上-右下的主对角线填充2.0的对角矩阵vec4 pos = vec4(1.0, 0.0, 0.0, 1.0);  // vec会被自动认为是列向量vec4 transformed = pos * model;       // 错误！GLSL 默认不支持行向量乘法vec4 transformed = pos * transpose(model); // 正确：转为列向量乘法\n\n时间不早了，今天就先写到这吧。真希望我能够有能力和时间，把这个系列更新到完结撒花。  \n欲知后事如何，且听下回分解。\n","tags":["Shadertoy"]},{"title":"从零开始的Shadertoy生活_02","url":"/2025/06/30/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Shadertoy%E7%94%9F%E6%B4%BB_02/","content":"02 glsl 语言：内置参数，函数与常量在上一章中，我们已经充分了解了glsl语言与C语言的异同。这一章将接着上一章的内容，继续补充完善glsl语言的内置函数与常量。在介绍完常量过后，我们将进一步了解内置参数。  \n内置函数glsl的内置函数有很多，在此无法一一列举，仅对最常用、最通用的函数进行介绍。（若想全面、深刻了解glsl语言，请参考 OpenGL相关标准 ）  \n数学计算函数// 三角相关radians(degrees)    // 角度转弧度degrees(radians)    // 弧度转角度sin(x), cos(x), tan(x)\t\t  // 三角函数asin(x), acos(x), atan(x)  \t  // 反三角函数sinh(x), cosh(x), tanh(x)     // 双曲函数// 指对幂pow(x, y)      // 指数 x^yexp(x)         // e指数 e^xexp2(x)        // 2指数 2^xlog(x)         // ln(x)log2(x)        // log2(x)sqrt(x)        // 平方根inversesqrt(x) // 1/sqrt(x)// 整数相关abs(x)        // 绝对值sign(x)       // 符号函数（-1, 0, 1）floor(x)      // 向下取整ceil(x)       // 向上取整round(x)      // 四舍五入trunc(x)\t  // 截断到整数fract(x)      // 小数部分（x - floor(x)）mod(x, y)     // 浮点数取模 (正整数为x % y)min(x, y), max(x, y)  // 最小/最大值clamp(x, min, max)    // x在min以下时返回min，在max以上时返回max，其余直接返回xmix(x, y, a)  // 线性插值（x*(1-a) + y*a）step(edge, x) // x &gt;= edge ? 1 : 0smoothstep(edge0, edge1, x) // x在edge0及以下时返回0，在edge1及以上时返回1，中间平滑差值（3次Hermite差值）\n\n注意事项：\n\n以上所有运算均可应用于 vec ，效果等同于对每一项分别操作。  \n三角函数、反三角函数默认使用弧度制。\npow 函数对于负数的非整数次方返回值不定（这是Undefined Behavior）。\nmod 函数不能用于整数，整数请用 a % b 计算。\nmod(x, y) = x - y * floor(x / y) ，即取模结果与y同号。  \nmin max clamp 会返回更宽的类型，即 min(float, int) -&gt; float max(vec3, float) -&gt; vec3 。\n\n// 向量相关length(x)     // 向量模长distance(p0, p1)  // 两点距离dot(x, y)     // 点积cross(x, y)   // 叉积normalize(x)  // 归一化向量，返回对应单位向量reflect(I, N) // 反射向量（I 为入射，N 为法线）refract(I, N, eta) // 折射向量（eta 为折射率）faceforward(N, I, Nref) // 确保法线 N 最终朝向与参考方向 Nref 相反的一侧any(x)  // 任意分量为真则返回 trueall(x)  // 所有分量为真则返回 truelessThan(x, y), greaterThan(x, y)  // 分量逐项比较\n\n注意事项：\n\n叉乘 cross 仅适用于 vec3 。\nreflect 和 refract 的 I 与 N 参数都需要归一化。\nreflect(I, N) = I − 2 * (N ⋅ I) * N 。\n折射 refract 符合斯涅耳定律，全反射时返回反射角方向。\n\n// 矩阵相关transpose(M)      // 转置矩阵determinant(M)    // 行列式（仅适用于方阵）inverse(M)       // 逆矩阵（仅适用于方阵）outerProduct(c, r) // 外积（生成矩阵）\n\n注意事项：  \n\n仅部分高版本（GLSL 3.30+（OpenGL 3.3+））支持非方阵（如 mat2x3 ），但是计算消耗大于方阵，因此尽可能少使用非方阵。\n\n以上数学函数将贯通整个 Shader 学习过程，请熟记于心（记不住也没关系，多写自然熟练）。  \ntexture 相关纹理函数由于纹理比较复杂，此处暂且按下不表，后面会单独开一个章节讨论纹理和缓冲（Buffer）。\n常量学过C语言的同学都知道，常量就是 const ，声明必须同时定义，一旦定义就不能修改。如果真的这么简单，那根本没必要单开一节来讨论常量  \nglsl中大致符合以上标准的“常量”共有3种：const #define 和 uniform ， 我们一个个看。  \nconst：真正的“常量”和C语言中的一样，const常量是真正的“常量”，在作用域内保持值不可变。如果定义在主函数或是其他某个函数内部，那么const常量将在每次调用这个函数的时候被定义，生命周期持续到函数结束；如果定义在全局（即写在所有函数外面），const常量将仅在编译开始后定义一次，每帧不再重新定义。\n// 全局 const（全局只定义一次）const vec3 c_sky = vec3(0.53, 0.81, 0.92);void mainImage( out vec4 fragColor, in vec2 fragCoord )&#123;    // 归一化像素    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);        // 局部 const（每次调用 mainImage 函数时重新定义）    const vec3 ORANGE = vec3(1.0, 0.4, 0.0);    fragColor = vec4(mix(c_sky, ORANGE, uv.y * 0.7), 1.0);&#125;\n\n\n\n#define：“常”而非“量”和C语言中的一样，#define 是预处理器指令，在编译之前就直接做文本替换，不消耗空间，几乎不影响运行效率。所以这不是一种“量”，只是一种宏定义的别名。相比于const，#define 不会进行类型检查，也就是不会被编辑器的红色波形曲线发现，但有可能造成 Compile Error。  \n#define PI 3.1415926538#define TWO_PI 6.28318530718  // 2 * PIvoid mainImage(out vec4 fragColor, in vec2 fragCoord) &#123;    // 归一化像素坐标到 [0, 1] 并居中    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);        // 计算极坐标（半径和角度）    float radius = length(uv);    float angle = atan(uv.y, uv.x);        // 使用 PI 控制圆环的周期性（每 PI/2 弧度变换一次颜色）    float colorMask = sin(angle * 4.0 + radius * 10.0);  // 4.0 = 2*PI/(PI/2)        // 生成彩虹色    vec3 rainbow = 0.5 + 0.5 * cos(angle + vec3(0.0, TWO_PI/3.0, TWO_PI*2.0/3.0));        // 圆环效果（内半径 0.3，外半径 0.4）    float ring = smoothstep(0.3, 0.31, radius) - smoothstep(0.4, 0.41, radius);        // 混合颜色和圆环    fragColor = vec4(rainbow * ring * colorMask, 1.0);&#125;\n\n\n\nuniform：“量”而不“常”uniform是glsl有别于C的一大特性：它用于传输从宿主程序（如 CPU）向着色器传递的运行时不可变的全局数据。换句话说，uniform常量是CPU向GPU传递数据的单向管道。uniform常量将保持在运行时不变，也就是说在同一帧内每个像素点运行主函数时保持不变且不可修改；但是在不同帧运行之前，CPU可以修改传入的uniform的值。因此，uniform常量不是真正的“常”量。一些常见的uniform常量将在下一节：内置参数中给出。\n注：由于自定义uniform常量将涉及到OpenGL API在CPU端修改配置（主要是作者不会），本系列暂不考虑，仅讨论Shadertoy内制的uniform参数。\n内置参数新建一个Shadertoy在线着色器，点开代码区顶部的“着色器输入”，你会发现这些内置参数：  \nuniform vec3      iResolution;           // viewport resolution (in pixels)uniform float     iTime;                 // shader playback time (in seconds)uniform float     iTimeDelta;            // render time (in seconds)uniform float     iFrameRate;            // shader frame rateuniform int       iFrame;                // shader playback frameuniform float     iChannelTime[4];       // channel playback time (in seconds)uniform vec3      iChannelResolution[4]; // channel resolution (in pixels)uniform vec4      iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: clickuniform samplerXX iChannel0..3;          // input channel. XX = 2D/Cubeuniform vec4      iDate;                 // (year, month, day, time in seconds)\n\n根据我们对 uniform 常量的了解，我们知道，这是每一帧CPU将要传递给GPU的数据。\n","tags":["Shadertoy"]}]