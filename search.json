[{"title":"Add_BGM","url":"/2025/05/19/Add_BGM/","content":"向主页添加了第一首歌，然后又添加了4首。  \n记录一下操作：  \n\n打开 aaaaa_online\\_config.redefine.yml 找到 plugins/aplayer/audios ，复制一份如下代码：  \n\nartist: 葉月ゆら # audio artist\nurl: /music/HAMELN.mp3 # audio url\ncover: /images/cover/HAMELN.png # audio cover url\nlrc: # audio cover lrc\n\n\n\n\n更改作者、曲名；  \n\n在 aaaaa_online\\node_modules\\hexo-theme-redefine\\source\\music 目录下保存一份 mp3 ，在 aaaaa_online\\node_modules\\hexo-theme-redefine\\source\\images\\cover 目录下保存一份背景图；  \n\n上传！\n\n\n这个播放器插件声音有点大，而且没办法调节声音大小，略显不方便。以后找机会换一个能调声音大小的。\n","tags":["Website_building"]},{"title":"Make Friends","url":"/2025/05/19/Make%20Friends/","content":"添加了友链功能。  \n记录一下操作：  \n\n打开 aaaaa_online\\source\\_data\\links.yml ，添加以下内容：  \n\n - name:  # Name\n   link:  # Friend&#39;s link\n   description:  # Individual signiture\n   avatar:  # Photo\n\n\n\n\n编辑姓名、友链、个签、头像；  \n\n上传！\n\n\n","tags":["Website_building"]},{"title":"ColorMaster 第一个lua项目","url":"/2025/06/19/ColorMaster%20%E7%AC%AC%E4%B8%80%E4%B8%AAlua%E9%A1%B9%E7%9B%AE/","content":"在 _Arahc_ 的游说下，自学了 lua 语言，并依据下午刚得来的灵感，创作了第一个样例小游戏：ColorMaster ！  \n仓库链接: ColorMaster: my first lua project   \n在这里记录下lua语言的学习与配置过程，以及建立项目的全流程。\nlua语言\nlua语言\n\nlua是基于C语言开发的轻量级解释执行的编程语言，语法学习曲线极为平坦，体感极为舒适 (乐不思C, C++, python) ，而且性能继承自C语言，比python高效。\n\n\n配置环境\n\n我的环境是 Windows + VSCode，我先是从网站上下载了lua的源代码，再根据 教程 一步步安装。\n安装好后，不要忘记配置环境变量！\nVSCode 有现成的lua插件 Lua (sumneko) 和 Lua (Tencent). 安装后编辑器即可检查语法错误。\n\n\n\nLove2d 库 (LÖVE)\nLÖVE\n\n这是一个专为lua语言开发的2d游戏开发框架，兼具跨平台、轻量级等优势。\n\n\n下载与配置\n\n访问 LÖVE官网 下载最新版本，安装至任意目录下，并添加到环境变量即可使用。\n\n\n运行代码\n\n在VSCode中打开终端，并跳转至代码根目录下；\n输入指令 love . 即可运行当前目录下的 main.lua 文件（文件名不可修改）。\n\n\n打包为可执行文件\n\n在VSCode中打开终端，并跳转至代码根目录下；\n\n将LÖVE安装目录中的 love.exe 文件复制进代码根目录；\n\n在终端中依次输入：\nzip -r mygame.love .cmd /c &quot;copy /b love.exe+mygame.love mygame.exe&quot;\n\n这样得到的就是独立的 .exe 文件了！\n\n\n\n\nColorMaster灵感来源于配色时口胡十六进制色号。这个小游戏给出会给出一个色块，并让你输入颜色对应的色号。输入后，游戏会计算并输出你的分数。练习口胡色号的技巧！  \n仓库链接再放送: ColorMaster: my first lua project \n","tags":["Projects"]},{"title":"Musician更新：支持Linux风格指令集","url":"/2025/05/26/Musician%E6%9B%B4%E6%96%B0%EF%BC%9A%E6%94%AF%E6%8C%81Linux%E9%A3%8E%E6%A0%BC%E6%8C%87%E4%BB%A4%E9%9B%86/","content":"仓库:  aaaaa114514-1&#x2F;musician: An individual music player with a little bit more functions.   \nMusician 迎来了上线以来的第一次更新！  \n\n更新了 Linux 风格的指令集  \n增加了默认曲库配置，让初次使用更加快捷\n\n今后，可以使用 :q :? 等熟悉的指令来快捷操作 Musician 啦！\n","tags":["Projects"]},{"title":"Musician音乐播放器","url":"/2025/05/21/Musician%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/","content":"仓库放开头:  aaaaa114514-1&#x2F;musician: An individual music player with a little bit more functions. \n听音乐是个不错的爱好。  \n但是，一放音乐就卡的Windows自带播放器体感极度不舒适；mediaPlayer虽然可以播放音乐，但是它的UI风格实在有点年代感，用着也不太习惯。  \n恰好，一年前，在学习网络爬虫的时候，我用python写了个酷狗音乐的爬虫，25年年初的时候翻出来测试，发现已经跟不上版本了；恰好，我在群里听说，网易云的本地文件加密是用的按位 ^163 的方法。  \n于是，在2025年3月，我决定用python写一个小型Project，用命令行写一个播放器，集成酷狗和网易云下载工具，以解决自己的播放器问题。  \n不到一个礼拜，代码的主要部分就完工了。后来在使用过程中陆续发现了一些bug，顺便开发了一些必要的功能，比如说一开始没做的“上一曲”（不知道我当时为什么没设计这么重要的功能），为了睡眠质量而开发的“定时关闭”，以及后来加上的“数据统计 history”等等。  \n现在，这个项目已经初具雏形，虽然离趋于完善还有很长的路，不过可以先分享出来，一边接受反馈，一边修改。  \n仓库是今天新建的，先写了英文版的README，后来又加了中文版。略微修改了原来程序的接口，使得移植更加方便了。中文版的README一同贴出来：  \n注意：此处的README不实时更新，具体请以仓库中的为准！  \nMusician一个拥有曲库管理功能的命令行音乐播放器代码 aaaaa\nMusician 是一个命令行控制的音乐播放器，专为程序员音乐爱好者设计，支持：\n\n听歌\n从酷狗音乐或网易云音乐免费下载歌曲\n建立个人曲库\n记录播放历史\n\n程序使用 Python 编写，播放功能基于 pygame。由于作者编程水平有限，可能存在一些 Bug——欢迎反馈，我会尽力修复！\n\n程序概览musician 目录包含以下文件：\nmusician/├── history.txt        # 播放历史记录  ├── Icon.ico           # 程序图标  ├── musician.exe       # 可执行文件（用户使用）  ├── musician.py        # 源代码（开发者查看）  ├── README.md          # 说明文档  └── savedata.txt       # 配置文件  \n\n\n用户：修改 savedata.txt（仅首次配置），然后运行 musician.exe。\n开发者：可查看 musician.py 和 savedata.txt。\n\n\n用户指南1. 配置 savedata.txt该文件定义了路径和设置：\nC:\\Users\\Netease\\CloudMusic\\Cache\\Cache   # 网易云音乐缓存路径  D:\\BGM\\Download&amp;Decode                    # 下载/解码目录  D:\\BGM\\Download&amp;Decode\\temp               # 临时文件存放  D:\\BGM\\Lis                                # 播放列表文件夹  D:\\BGM                                    # 主音乐库  0.4                                       # 默认音量（0–1）  30                                        # 搜索匹配阈值（%）  1d4e5b7decbe434048e596ae2d597adb          # 酷狗 token（后32位）  D:\\BGM\\Settings\\history.txt               # 历史记录文件路径  \n\n配置步骤\n网易云缓存路径\n\n打开 网易云音乐桌面端 → 设置 → 下载 → 复制缓存路径。\n在路径末尾手动添加 \\Cache（如 C:\\...\\Cache\\Cache）。\n\n\n音乐库文件夹创建以下目录（示例名称）：\nBGM/  ├── Download&amp;Decode/  # 用于下载/解码  │   └── temp/         # 临时文件  └── Lis/              # 播放列表存放  \n\n将它们的路径填入 savedata.txt 的第 2–5 行。\n\n酷狗 Token（可选）\n\n登录 酷狗音乐官网。\n播放任意歌曲 → 按 F12 打开开发者工具 → Network（网络） 标签。\n找到 https://wwwapi.kugou.com/play/songinfo? 的请求。\n复制 token 参数的最后32位字符，即在...5e6de之后的部分（如 55f2409f72970daa21bdc63acee305db）。\n粘贴到 savedata.txt 第 8 行。\n如果不需要使用酷狗下载音乐，可跳过此步。\n\n\n历史记录文件指定 history.txt 的路径（第 9 行）并将给出的 history.txt 文件移到指定路径下，程序会自动管理该文件。\n\n\n\n2. 命令速查在 &gt;&gt; 后输入命令（不区分大小写）。\n基础操作\n\n\n命令\n功能\n\n\n\nquit&#x2F;exit&#x2F;end\n退出程序（尽可能不要用右上角的×退出程序）。\n\n\nhelp\n显示所有命令。\n\n\n网易云音乐\n\n\n命令\n功能\n\n\n\ncheck163\n列出缓存歌曲（若报错，请检查网络连接）。\n\n\ndecode &lt;编号&gt;\n解码歌曲（如 decode 3 或 decode 2 5-9 4）。\n\n\nclear163\n清空缓存（先关闭网易云桌面端！）。\n\n\n酷狗音乐\n\n\n命令\n功能\n\n\n\nsearch &lt;歌名&gt;\n搜索（如 search 夏の紫苑）。\n\n\ndownload &lt;编号&gt;\n下载（VIP 歌曲需先登录酷狗VIP账号）。\n\n\n播放控制\n\n\n命令\n功能\n\n\n\nplay&#x2F;pause\n播放&#x2F;暂停。\n\n\nplay &lt;编号&gt;\n播放指定歌曲（如 play 1-3 5）。\n\n\nadd &lt;编号&gt;\n添加到播放列表。\n\n\nmode &lt;single/cycle/random&gt;\n设置播放模式（单曲循环&#x2F;列表循环&#x2F;随机）。\n\n\nstop\n停止播放。\n\n\nlast&#x2F;previous\n上一首。\n\n\nnext\n下一首。\n\n\nrestart&#x2F;replay\n重新播放当前歌曲。\n\n\nvolume &lt;数值&gt;\n调整音量（0–100%，如 volume 40）。\n\n\n音乐库 &amp; 历史\n\n\n命令\n功能\n\n\n\nsavelist\n显示已下载歌曲。\n\n\nsave &lt;Lis/BGM&gt;\n将歌曲移至 Lis（播放列表）与 BGM（音乐库）&#x2F;仅移至BGM。\n\n\nclear\n清空下载列表。\n\n\nlibrary\n浏览音乐库。\n\n\nlookup &lt;歌名&gt;\n搜索音乐库。\n\n\ntimelimit &lt;分钟&gt;\n设置最长播放时间（如 timelimit 45）。\n\n\nhistory\n查看播放历史。\n\n\n?\n显示当前播放的歌曲。\n\n\n\n曲库以mp3格式为默认存储格式，其他格式的音频将无法播放。你可以将原本的个人曲库直接迁移到 BGM 和 Lis 列表下。\n请务必在 BGM 和 Lis 列表下分别存放至少1个mp3文件，否则曲库会崩溃！ \n\n开发者说明\n先阅读用户指南了解功能逻辑。\n查看 musician.py——代码应该还算易懂（大概）。😊\n在终端用指令 pyinstaller --onefile musician.py -i Icon.ico 来将 .py 文件打包成 .exe 文件。\n\n\n祝你在 Musician 的陪伴下享受音乐！ 🎵\n","tags":["Projects"]},{"title":"The_First_Step","url":"/2025/05/17/The_First_Step/","content":"个人网页终于建出来了！感谢 Arahc 的帮助！  \n友情链接：  Arahc’s Home - A simple blog site.  \n时间不早了，今天测完网页就睡。  \n记录一下操作：  \n\n$ hexo clean 清除generate的内容;\n$ hexo g generate: 生成基于新的内容的 bulider;  \n$ hexo s server: 开启本地服务器，用于测试;  \n(默认在 http://localhost:4000/ 打开本地测试)\n\n\n$ hexo d deploy: 部署到网页，发布到公网。\n\n在 Github仓库 可以看到上传的内容与上传的进度。由于上传很慢，所以要本地测试后再上传。  \n","tags":["Website_building"]},{"title":"从零开始的Shadertoy生活_01","url":"/2025/06/30/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Shadertoy%E7%94%9F%E6%B4%BB_01/","content":"序2025暑学期，挤破头选到一门像素着色艺术，上了几节课，感觉确实很有意思，不过Workload比较大。  \n但是，大Workload × Coding × 兴趣型选手 &#x3D; A  \n像素着色艺术布置了一个可选的hw0，是专门设计给有Project想法的同学的，算额外加分。刚好我有Idea，箭在弦上，不得不发，一发不可收拾。一不小心一口气写完后意犹未尽，回望来时的路，也就是和Shadertoy的这一段共处时间，不禁想要写一段Shadertoy的入门教程，一方面方便自己随时回来复习，另一方面也大力传教种草，方便Shader后浪推前浪。此系列不定期更新，争取更完 成为我网站完结的第一个系列。  \n考虑到篇幅原因，本篇将默认读者有一定的C语言基础，并对计算机结构有极为基本的了解。至于兴趣，我是在逐渐熟悉Shadertoy的过程中产生的，相信读者也会同样感受到创造过程中强烈的正反馈。\n事不宜迟，我们从 Shadertoy 和 glsl 语言 开始谈起。  \nShadertoyShadertoy 是一个支持编译glsl语言的在线编译器，同时也是一个交流shader（中文翻译：着色器）的黑客社区。这里的学术风气很友好，有不停贡献的萌新，也有热心讲解的大佬。（不过没人来评价我的作品，是太简单了吗）打个广告，欢迎来关注我：aaaaa114514   \nShadertoy 社区评判好作品的标准有：画的好看&#x2F;仿真，短代码配惊艳效果。由于只用GPU而不用CPU内存的特性，glsl语言有极其惊艳的压缩能力，可以将几分钟的视频压缩到几kb（几乎全是代码）。因此，很多系统或游戏的开场界面会使用闲置的GPU来运行Shader，渲染好看的微动画商标。  \nglsl 语言配置环境glsl语言配置环境非常轻松，在这里介绍两种方法：  \n\n访问 Shadertoy ，点击右上角的“新建”按钮，写完代码后点击代码区左下角三角形按钮即可编译，然后在左侧的预览框中看到运行效果。\n使用 VSCode。安装插件 Shader Toy (by Adam Stevenson) 和 Shader language support for VS Code (by slevesque) 并重启VSCode，然后新建一个后缀名 .glsl 的文件即可。需要注意的是，编译时需要右键代码区，点击 Shader Toy: Show GLSL Preview 或 Shader Toy: Show Static GLSL Preview 选项（据说区别是后者不再动态响应代码修改或者键鼠输入，但是实测并没有区别），即可在屏幕右侧或下侧看到运行效果。\n\nglsl语言与C语言glsl语言是一种C语言的变体，继承了很多C的特性，但是你想要的C的好用功能，glsl几乎都没有。当然，这得从glsl完全脱离内存讲起（这是主线，非常重要）。众所周知，GPU是一堆擅长线性计算的小学生，也就是擅长多次相似的并行计算，而非少量复杂的计算。因此，glsl语言的程序核心，对应C语言里的主函数main，格式如下：  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )&#123;    // Normalized pixel coordinates (from 0 to 1)    vec2 uv = fragCoord/iResolution.xy;    // Time varying pixel color    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));    // Output to screen    fragColor = vec4(col,1.0);&#125;\n\n如上代码其实是Shadertoy官网上新建Shader后的示例代码。主函数 mainImage 固定输出 (注意是输出out, 而非返回return) 一个四维数组fragColor表示颜色，读入一个fragCoord表示坐标。“像素着色艺术”这个名字起得名副其实，正如主函数输入像素（坐标），输出颜色，你写代码的部分就是着色的过程，产出的就是艺术（能不能欣赏得来见仁见智）。\n回到主线，正因为glsl语言不使用内存而只用显存，所以这个主函数会被每个GPU单元、每一帧运行一次，输出的结果会先存在进程的私有寄存器内，然后等待所有线程结束后，统一将每个线程输出的fragColor存入显存里的帧缓冲区的二维数组中，最后统一传给显示器，或者参与下一帧的计算。\n因为没有内存，所以glsl语言里没有C语言的类class（只有struct，但是是C语言的类，不支持成员函数，另外不支持结构体数组）、地址操作（指针、取地址、解引用，申请内存，引用传参等）、输入输出操作（input&#x2F;printf等）、几乎所有隐式转换（包括任意类型向bool的转换、int和float的转换等），更没有stdio.h&#x2F;stdlib.h中的绝大多数函数，C++的库更是无需多言。另外，glsl语言还不支持全局变量（const可以，详情见后）、读取前一帧Image内容（Buffer可以，详情见后）和所有非确定运行次数的代码（如while(1)-break结构、递归调用、动态大小数组等）。现在知道C语言的方便之处了吧  \n注：需要注意的是，在不同系统、不同环境中运行glsl语言的代码，可能会产生不同的结果。甚至，连glsl语言本身都有好多套不同的标准，这背后有资本的力量。有些良心系统上支持while(1)-break等结构，但是这并不是符合所有标准的，因此还是要尽可能避免使用。  \n听起来是不是极其不方便？确实，glsl上手有一定难度。不过当你逐渐熟悉这些限制之后，你会发现这门语言运行效率之高，领略GPU带来的CPU无法取代的并行计算效率，逐渐被这门语言的可视化艺术和各路高手各显神通创造的神作所折服。  \n差点忘记说了，glsl语言也有自己的语法糖，用起来还算方便。 （还没有从C里面删掉的多） \n\n示例代码中的 vec2 和 vec4 就是glsl的原生数组，一共有三种: vec2&#x2F;vec3&#x2F;vec4 ，每种都默认是float数组，还有变体int数组 ivec3 ，无符号整型数组 uvec4 和bool数组 bvec2 各三种。这些数组支持比较方便的构造和访问、修改和运算操作，样例如下：\n// 构造//// 1. 直接赋值vec2 uv = vec2(0.5, 0.5);vec3 color = vec3(0.7, 0.4, 0.2);// 2. 单值填充vec3 gray = vec3(0.5); // 等效于 (0.5, 0.5, 0.5)// 3. 混合构造vec4 transparentRed = vec4(vec3(1.0, 0.0, 0.0), 0.5); // RGB + Alphavec4 rgba = vec4(color, 1.0); // 扩展为 RGBA (等效于vec4(0.7, 0.4, 0.2, 1.0))\n\n// 访问和修改//vec4 pos = vec4(1.0, 2.0, 3.0, 4.0);  // 1. 标准下标（类似C数组）float x = pos[0]; // x = 1.0  // 2. 分量别名（支持 .xyzw / .rgba / .stpq ，但不可混用）float y = pos.y;   // y = 2.0float a = pos.a;   // Alpha = 4.0float t = pos.t;   // 纹理坐标 t = 2.0（与 .y 相同）  // 3. 链式访问（Swizzling）vec2 xy = pos.xy;  // 提取前两维 (1.0, 2.0)vec3 pos_bgr = pos.bgr; // 反转RGB通道 (3.0, 2.0, 1.0)vec4 pos_rara = pos.rara; // 允许重复提取 (1.0, 4.0, 1.0, 4.0)pos.wx = vec2(5.0, 6.0); // 修改 pos = (6.0, 2.0, 3.0, 5.0)\n\n// 运算//vec3 a = vec3(1.0, 2.0, 3.0);vec3 b = vec3(0.1, 0.2, 0.3);  // 1. 逐分量运算vec3 c = a + b;    // (1.1, 2.2, 3.3)vec3 d = a * 2.0;  // 标量乘法 (2.0, 4.0, 6.0)vec3 e = a + 3.0;  // 3.0被隐式转换为 vec3(3.0), 运算结果为 (4.0, 5.0, 6.0)float dotProduct = dot(a, b); // 点积vec3 crossProduct = cross(a, b); // 叉乘  // 2. 比较运算bvec3 isGreater = greaterThan(a, b); // (true, true, true)bool isEqual = (a == b); // false\n\nglsl语言有原生矩阵 mat2 mat3 mat4 （只有方阵）：  \n// 定义//mat2 m2 = mat2(1.0, 2.0,   // 第一 列!!               3.0, 4.0);  // 第二 列!!// 以上代码画出了矩阵：// [1.0, 3.0]// [2.0, 4.0]// 这是符合数学直觉的，但是有点反人类// n个n维向量填充定义vec3 col0 = vec3(1.0, 2.0, 3.0); // 第一列vec3 col1 = vec3(4.0, 5.0, 6.0); // 第二列vec3 col2 = vec3(7.0, 8.0, 9.0); // 第三列mat3 m3 = mat3(col0, col1, col2); // 3x3 矩阵// 也可以向量-标量混合定义mat2 m4 = mat2(1.0, 2.0,  // 第一列 (1.0, 2.0)              vec2(3.0)); // 第二列 (3.0, 0.0)// 但不可以这样！vec2 a = vec2(1.0, 2.0);vec2 b = vec2(3.0, 4.0);vec2 c = vec2(5.0, 6.0);vec3 d = vec3(7.0, 8.0, 9.0);mat3 m = mat3(a, b, c, d); // 编译错误！参数不匹配\n\n// 矩阵与矩阵运算//// 矩阵之间的加、减、乘都符合数学规则，数乘同样符合规则mat2 m = mat2(1.0, 2.0, 3.0, 4.0);mat2 mInv = inverse(m); // 逆矩阵float det = determinant(m); // 行列式 = -2.0mat2 mT = transpose(m); // 矩阵的转置\n\n// 矩阵与向量乘法//mat4 model = mat4(2.0);  // 这是左上-右下的主对角线填充2.0的对角矩阵vec4 pos = vec4(1.0, 0.0, 0.0, 1.0);  // vec会被自动认为是列向量vec4 transformed = pos * model;       // 错误！GLSL 默认不支持行向量乘法vec4 transformed = pos * transpose(model); // 正确：转为列向量乘法\n\n时间不早了，今天就先写到这吧。真希望我能够有能力和时间，把这个系列更新到完结撒花。  \n欲知后事如何，且听下回分解。\n","tags":["Shadertoy"]}]