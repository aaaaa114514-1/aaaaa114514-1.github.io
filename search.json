[{"title":"BetterBlackBoard：bb美化工程","url":"/2026/01/26/BetterBlackBoard%EF%BC%9Abb%E7%BE%8E%E5%8C%96%E5%B7%A5%E7%A8%8B/","content":"仓库放开头：aaaaa114514-1&#x2F;BetterBlackBoard: A local beautification version of blackboard (bb) of ShanghaiTech University\n\n\n早就看上科大的bb系统界面UI不顺眼了，番茄炒鸡蛋的配色实在是有点恶俗，每次打开界面查作业的时候心情都不好了。终于，在考完试之后，可算有空来边学边写，搞一个bb美化工程了。正好最近刚玩完、并安利朋友玩完了《魔法少女的魔女审判》，正在处于戒断期，于是在这里夹带了一点私货。\n如何本地部署1. 下载必要文件先去仓库里下载并准备好以下关键文件与目录结构：\n.├─ code.js├─ css│  ├─ brand.css│  └─ colorpalette.generated.modern.css└─ images   ├─ bblearn_2011_bg.png   └─ pinpai.png\n\n2. 修改资源路径打开 code.js，找到 第 10～13 行 ：\n// @resource     brand   file:///D:/desktop/BetterBlackBoard/css/brand.css// @resource     palette file:///D:/desktop/BetterBlackBoard/css/colorpalette.generated.modern.css// @resource     bodybg  file:///D:/desktop/BetterBlackBoard/images/bblearn_2011_bg.png// @resource     pinpai file:///D:/desktop/BetterBlackBoard/images/pinpai.png\n\n将其中的 file:///D:/desktop/BetterBlackBoard/...替换为你本地实际存放这些文件的路径。\n3. 安装 Tampermonkey在你的浏览器中安装 Tampermonkey 插件：\n\nMicrosoft Edge从 Microsoft Edge Add-ons 安装 Tampermonkey\nGoogle Chrome从 Chrome Web Store 安装 Tampermonkey\n\n4. 导入脚本\n打开 Tampermonkey 管理界面\n新建一个脚本\n将 code.js 中的全部代码复制进去\n按 Ctrl + s 保存脚本\n\n5. 验证是否生效访问 Blackboard（bb） 页面，确认：\n\nTampermonkey 中脚本已启用\n页面样式已发生变化\n\n如果没有效果，请重点检查：\n\n脚本是否启用\n资源路径是否正确\n浏览器是否有本地文件访问权限限制（浏览器拓展管理设置“允许用户脚本”“允许访问文件网址”需要勾选）\n\n注：将bb本身主题改为默认，加载会更快更流畅！\n\n自定义你的 BB 页面皮肤！在已经成功部署并确认生效的前提下，可以进行自定义的美化。\n\n替换顶部图片\n\n可以直接替换 images/pinpai.png为你自己的图片，显示在页面顶部位置。（这张这么长的图是我自己拼的，确实挺难找的）\n2026.1.28更新：添加了新的主题选择，现在可以在 images/skins里直接找喜欢的顶图，然后复制进 images，并更名为 pinpai.png就可以啦！\n\n修改主题配色\n\n主题主要由以下两个文件共同决定：\n\ncss/brand.css\ncss/colorpalette.generated.modern.css\n\n同时修改这两个文件开头的配色变量，可以修改主题色。\n2026.1.28更新：在两个文件代码头部添加了可选的主题色配色方案，注释&#x2F;取消注释即可选择想要的主题配色。\n\n这个项目仍在持续更新中，后续可能将加入更多功能与可定制选项。\n","categories":["项目","BetterBlackBoard：bb美化工程"],"tags":["Projects"]},{"title":"Photor更新：aaaUnlocker发布","url":"/2025/10/30/Photor%E6%9B%B4%E6%96%B0%EF%BC%9AaaaUnlocker%E5%8F%91%E5%B8%83/","content":"仓库放开头：aaaaa114514-1&#x2F;Photor: A light photo viewer \n对于具体项目的介绍请移步至：Photor：轻量级图片加密查看工具 | aaaaa online\n为了防止误操作加密导致图片文件无法恢复，我在最新版本中添加了 aaaUnlocker.exe ，且直接继承了“复制-重命名-运行”便捷操作方式。只需要将可执行文件 aaaUnlocker.exe 复制进入需要批量解密的根目录，重命名为 你的密码.exe ，并双击运行，即可一键完成解密！\n另：向安装包内添加了 README.md ，现在安装后可以查看教程了\n\nPhotor 项目还会持续更新，未来可能会支持更多功能，进一步优化用户体验。敬请期待！\n","categories":["项目","Photor图片查看器"],"tags":["Projects"]},{"title":"Musician更新：支持Linux风格指令集","url":"/2025/05/26/Musician%E6%9B%B4%E6%96%B0%EF%BC%9A%E6%94%AF%E6%8C%81Linux%E9%A3%8E%E6%A0%BC%E6%8C%87%E4%BB%A4%E9%9B%86/","content":"仓库:  aaaaa114514-1&#x2F;musician: An individual music player with a little bit more functions.\nMusician 迎来了上线以来的第一次更新！\n\n更新了 Linux 风格的指令集\n增加了默认曲库配置，让初次使用更加快捷\n\n今后，可以使用 :q :? 等熟悉的指令来快捷操作 Musician 啦！\n","categories":["项目","Musician音乐播放器"],"tags":["Projects"]},{"title":"Musician音乐播放器","url":"/2025/05/21/Musician%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/","content":"仓库放开头:  aaaaa114514-1&#x2F;musician: An individual music player with a little bit more functions.\n听音乐是个不错的爱好。\n但是，一放音乐就卡的Windows自带播放器体感极度不舒适；mediaPlayer虽然可以播放音乐，但是它的UI风格实在有点年代感，用着也不太习惯。\n恰好，一年前，在学习网络爬虫的时候，我用python写了个酷狗音乐的爬虫，25年年初的时候翻出来测试，发现已经跟不上版本了；恰好，我在群里听说，网易云的本地文件加密是用的按位 ^163 的方法。\n于是，在2025年3月，我决定用python写一个小型Project，用命令行写一个播放器，集成酷狗和网易云下载工具，以解决自己的播放器问题。\n不到一个礼拜，代码的主要部分就完工了。后来在使用过程中陆续发现了一些bug，顺便开发了一些必要的功能，比如说一开始没做的“上一曲”（不知道我当时为什么没设计这么重要的功能），为了睡眠质量而开发的“定时关闭”，以及后来加上的“数据统计 history”等等。\n现在，这个项目已经初具雏形，虽然离趋于完善还有很长的路，不过可以先分享出来，一边接受反馈，一边修改。\n仓库是今天新建的，先写了英文版的README，后来又加了中文版。略微修改了原来程序的接口，使得移植更加方便了。中文版的README一同贴出来：\n注意：此处的README不实时更新，具体请以仓库中的为准！\nMusician一个拥有曲库管理功能的命令行音乐播放器代码 aaaaa\nMusician 是一个命令行控制的音乐播放器，专为程序员音乐爱好者设计，支持：\n\n听歌\n从酷狗音乐或网易云音乐免费下载歌曲\n建立个人曲库\n记录播放历史\n\n程序使用 Python 编写，播放功能基于 pygame。由于作者编程水平有限，可能存在一些 Bug——欢迎反馈，我会尽力修复！\n\n程序概览musician 目录包含以下文件：\nmusician/├── history.txt        # 播放历史记录  ├── Icon.ico           # 程序图标  ├── musician.exe       # 可执行文件（用户使用）  ├── musician.py        # 源代码（开发者查看）  ├── README.md          # 说明文档  └── savedata.txt       # 配置文件  \n\n\n用户：修改 savedata.txt（仅首次配置），然后运行 musician.exe。\n开发者：可查看 musician.py 和 savedata.txt。\n\n\n用户指南1. 配置 savedata.txt该文件定义了路径和设置：\nC:\\Users\\Netease\\CloudMusic\\Cache\\Cache   # 网易云音乐缓存路径  D:\\BGM\\Download&amp;Decode                    # 下载/解码目录  D:\\BGM\\Download&amp;Decode\\temp               # 临时文件存放  D:\\BGM\\Lis                                # 播放列表文件夹  D:\\BGM                                    # 主音乐库  0.4                                       # 默认音量（0–1）  30                                        # 搜索匹配阈值（%）  1d4e5b7decbe434048e596ae2d597adb          # 酷狗 token（后32位）  D:\\BGM\\Settings\\history.txt               # 历史记录文件路径  \n\n配置步骤\n网易云缓存路径\n\n打开 网易云音乐桌面端 → 设置 → 下载 → 复制缓存路径。\n在路径末尾手动添加 \\Cache（如 C:\\...\\Cache\\Cache）。\n\n\n音乐库文件夹创建以下目录（示例名称）：\nBGM/  ├── Download&amp;Decode/  # 用于下载/解码  │   └── temp/         # 临时文件  └── Lis/              # 播放列表存放  \n\n将它们的路径填入 savedata.txt 的第 2–5 行。\n\n酷狗 Token（可选）\n\n登录 酷狗音乐官网。\n播放任意歌曲 → 按 F12 打开开发者工具 → Network（网络） 标签。\n找到 https://wwwapi.kugou.com/play/songinfo? 的请求。\n复制 token 参数的最后32位字符，即在 ...5e6de之后的部分（如 55f2409f72970daa21bdc63acee305db）。\n粘贴到 savedata.txt 第 8 行。\n如果不需要使用酷狗下载音乐，可跳过此步。\n\n\n历史记录文件指定 history.txt 的路径（第 9 行）并将给出的 history.txt 文件移到指定路径下，程序会自动管理该文件。\n\n\n\n2. 命令速查在 &gt;&gt; 后输入命令（不区分大小写）。\n基础操作\n\n\n命令\n功能\n\n\n\nquit&#x2F;exit&#x2F;end\n退出程序（尽可能不要用右上角的×退出程序）。\n\n\nhelp\n显示所有命令。\n\n\n网易云音乐\n\n\n命令\n功能\n\n\n\ncheck163\n列出缓存歌曲（若报错，请检查网络连接）。\n\n\ndecode &lt;编号&gt;\n解码歌曲（如 decode 3 或 decode 2 5-9 4）。\n\n\nclear163\n清空缓存（先关闭网易云桌面端！）。\n\n\n酷狗音乐\n\n\n命令\n功能\n\n\n\nsearch &lt;歌名&gt;\n搜索（如 search 夏の紫苑）。\n\n\ndownload &lt;编号&gt;\n下载（VIP 歌曲需先登录酷狗VIP账号）。\n\n\n播放控制\n\n\n命令\n功能\n\n\n\nplay&#x2F;pause\n播放&#x2F;暂停。\n\n\nplay &lt;编号&gt;\n播放指定歌曲（如 play 1-3 5）。\n\n\nadd &lt;编号&gt;\n添加到播放列表。\n\n\nmode &lt;single/cycle/random&gt;\n设置播放模式（单曲循环&#x2F;列表循环&#x2F;随机）。\n\n\nstop\n停止播放。\n\n\nlast&#x2F;previous\n上一首。\n\n\nnext\n下一首。\n\n\nrestart&#x2F;replay\n重新播放当前歌曲。\n\n\nvolume &lt;数值&gt;\n调整音量（0–100%，如 volume 40）。\n\n\n音乐库 &amp; 历史\n\n\n命令\n功能\n\n\n\nsavelist\n显示已下载歌曲。\n\n\nsave &lt;Lis/BGM&gt;\n将歌曲移至 Lis（播放列表）与 BGM（音乐库）&#x2F;仅移至 BGM。\n\n\nclear\n清空下载列表。\n\n\nlibrary\n浏览音乐库。\n\n\nlookup &lt;歌名&gt;\n搜索音乐库。\n\n\ntimelimit &lt;分钟&gt;\n设置最长播放时间（如 timelimit 45）。\n\n\nhistory\n查看播放历史。\n\n\n?\n显示当前播放的歌曲。\n\n\n\n曲库以mp3格式为默认存储格式，其他格式的音频将无法播放。你可以将原本的个人曲库直接迁移到 BGM 和 Lis 列表下。\n请务必在 BGM 和 Lis 列表下分别存放至少1个mp3文件，否则曲库会崩溃！\n\n开发者说明\n先阅读用户指南了解功能逻辑。\n查看 musician.py——代码应该还算易懂（大概）。😊\n在终端用指令 pyinstaller --onefile musician.py -i Icon.ico 来将 .py 文件打包成 .exe 文件。\n\n\n祝你在 Musician 的陪伴下享受音乐！ 🎵\n","categories":["项目","Musician音乐播放器"],"tags":["Projects"]},{"title":"ColorMaster：第一个lua项目","url":"/2025/06/19/ColorMaster%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AAlua%E9%A1%B9%E7%9B%AE/","content":"在 _Arahc_ 的游说下，自学了 lua 语言，并依据下午刚得来的灵感，创作了第一个样例小游戏：ColorMaster ！\n仓库链接: ColorMaster: my first lua project\n在这里记录下lua语言的学习与配置过程，以及建立项目的全流程。\nlua语言\nlua语言\n\nlua是基于C语言开发的轻量级解释执行的编程语言，语法学习曲线极为平坦，体感极为舒适 (乐不思C, C++, python) ，而且性能继承自C语言，比python高效。\n\n\n配置环境\n\n我的环境是 Windows + VSCode，我先是从网站上下载了lua的源代码，再根据 教程 一步步安装。\n安装好后，不要忘记配置环境变量！\nVSCode 有现成的lua插件 Lua (sumneko) 和 Lua (Tencent). 安装后编辑器即可检查语法错误。\n\n\n\nLove2d 库 (LÖVE)\nLÖVE\n\n这是一个专为lua语言开发的2d游戏开发框架，兼具跨平台、轻量级等优势。\n\n\n下载与配置\n\n访问 LÖVE官网 下载最新版本，安装至任意目录下，并添加到环境变量即可使用。\n\n\n运行代码\n\n在VSCode中打开终端，并跳转至代码根目录下；\n输入指令 love . 即可运行当前目录下的 main.lua 文件（文件名不可修改）。\n\n\n打包为可执行文件\n\n在VSCode中打开终端，并跳转至代码根目录下；\n\n将LÖVE安装目录中的 love.exe 文件复制进代码根目录；\n\n在终端中依次输入：\nzip -r mygame.love .cmd /c &quot;copy /b love.exe+mygame.love mygame.exe&quot;\n这样得到的就是独立的 .exe 文件了！\n\n\n\n\nColorMaster灵感来源于配色时口胡十六进制色号。这个小游戏给出会给出一个色块，并让你输入颜色对应的色号。输入后，游戏会计算并输出你的分数。练习口胡色号的技巧！\n仓库链接再放送: ColorMaster: my first lua project\n","categories":["项目","ColorMaster小游戏"],"tags":["Projects"]},{"title":"从零开始的Shadertoy生活_00","url":"/2025/06/30/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Shadertoy%E7%94%9F%E6%B4%BB_00/","content":"从零开始的Shadertoy生活目录00 目录与序01 Shadertoy与glsl语言序2025暑学期，挤破头选到一门像素着色艺术，上了几节课，感觉确实很有意思，不过Workload比较大。\n但是，大Workload × Coding × 兴趣型选手 &#x3D; A\n像素着色艺术布置了一个可选的hw0，是专门设计给有Project想法的同学的，算额外加分。刚好我有Idea，箭在弦上，不得不发，一发不可收拾。一不小心一口气写完后意犹未尽，回望来时的路，也就是和Shadertoy的这一段共处时间，不禁想要写一段Shadertoy的入门教程，一方面方便自己随时回来复习，另一方面也大力传教种草，方便Shader后浪推前浪。此系列不定期更新，争取更完 成为我网站完结的第一个系列。\n考虑到篇幅原因，本系列将默认读者有一定的C语言基础，并对计算机结构有极为基本的了解。至于兴趣，我是在逐渐熟悉Shadertoy的过程中产生的，相信读者也会同样感受到创造过程中强烈的正反馈。\n参考资料\nThe Book of Shaders 这个系列写得非常好，适合入门，可惜没更完。\nShader 中文教程 非常全面的教程，推荐学习。\nThe OpenGL® Shading Language, Version 4.60.8 截至2025.7，这是最新版的glsl语言标准。\n\n特别鸣谢\nArahc  Arahc&#39;s Home - A simple blog site.   Arahc - Shadertoy BETA\nDrHow  DrHow - Shadertoy BETA  ARTS1308 - Shadertoy BETA\n\n","categories":["Shadertoy"],"tags":["Shadertoy"]},{"title":"Photor：轻量级图片加密查看工具","url":"/2025/10/10/Photor%EF%BC%9A%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%9B%BE%E7%89%87%E5%8A%A0%E5%AF%86%E6%9F%A5%E7%9C%8B%E5%B7%A5%E5%85%B7/","content":"仓库放开头：aaaaa114514-1&#x2F;Photor: A light photo viewer \n每个人电脑里都可能有一些隐私的照片，而在文件交换需求日益增长的今天，偶尔的发错文件又是难以避免的事情。\n那么，我们有没有办法避免隐私照片泄露呢？\n有的兄弟，有的。\nPhotor 是一款轻量级图片加密查看工具，支持高效的加密功能，同时支持自定义翻页键位。\n整个工具分为3个可执行文件： aaaLocker.exe aaaViewer.exe aaaSetUp.exe :\n\n每次加密时，只需将 aaaLocker.exe 复制入你需要加密的根目录，并把它重命名为 加密密码.exe ，双击即可一键加密根目录及各级子目录下的所有图片文件；\n\n每次打开文件时，只需运行 aaaSetUp.exe 并输入密码， aaaViewer.exe 即可加载好查看图片的密码，此时双击加密的图片，用 aaaViewer.exe 打开即可查看；\n\n上一次的输入的查看密码会自动记忆，不必重复输入\naaaSetUp.exe 还有修改键位的功能，当然也可以重置键位\n\n\n\n重要注意事项：加密过程暂为不可逆过程（解密器将在后续补全），注意在加密之前将图片手动备份！\n\n在这次 Photor 项目中，我首次尝试了用 iss 代码（Inno，一款非商用的安装包配置工具）来配置安装包，在 LLM 的帮助下完成了多个可执行文件的安装包配置。现在，即使是我的小工具，也可以有市面上软件类似的安装包界面了！帅！\n这次项目的 github 仓库里，我特地学习了一般项目的 github 仓库格式，尽可能规范化地建立文件夹和仓库文件，并把安装包放进了 release 里。这样，开发者和用户就能够快速地各取所需了。\n项目编写时间不长，但是正好遇上换新电脑，直到开始上传 github 才想起来 github 的 F2A 和 recovery_code 都在几百公里外、已经关机的旧电脑上，网页端 github 根本登不上去。还好有 github desktop ，我还可以正常 git 仓库。\n写这篇帖子时，我发现新电脑上还没有个人网页的上传本地仓库。回去又得迁移文件了。\n\nPhotor 项目还会持续更新，未来可能会支持更多功能，进一步优化用户体验。敬请期待！\n","categories":["项目","Photor图片查看器"],"tags":["Projects"]},{"title":"从零开始的Shadertoy生活_01","url":"/2025/06/30/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Shadertoy%E7%94%9F%E6%B4%BB_01/","content":"01 Shadertoy 与 glsl 语言我们从 Shadertoy 和 glsl 语言 开始谈起。\nShadertoyShadertoy 是一个支持编译glsl语言的在线编译器，同时也是一个交流shader（中文翻译：着色器）的黑客社区。这里的学术风气很友好，有不停贡献的萌新，也有热心讲解的大佬。（不过没人来评价我的作品，是太简单了吗）打个广告，欢迎来关注我：aaaaa114514\nShadertoy 社区评判好作品的标准有：画的好看&#x2F;仿真，短代码配惊艳效果。由于只用GPU而不用CPU内存的特性，glsl语言有极其惊艳的压缩能力，可以将几分钟的视频压缩到几kb（几乎全是代码）。因此，很多系统或游戏的开场界面会使用闲置的GPU来运行Shader，渲染好看的微动画商标。\nglsl 语言配置环境glsl语言配置环境非常轻松，在这里介绍两种方法：\n\n访问 Shadertoy ，点击右上角的“新建”按钮，写完代码后点击代码区左下角三角形按钮即可编译，然后在左侧的预览框中看到运行效果。\n使用 VSCode。安装插件 Shader Toy (by Adam Stevenson) 和 Shader language support for VS Code (by slevesque) 并重启VSCode，然后新建一个后缀名 .glsl 的文件即可。需要注意的是，编译时需要右键代码区，点击 Shader Toy: Show GLSL Preview 或 Shader Toy: Show Static GLSL Preview 选项（据说区别是后者不再动态响应代码修改或者键鼠输入，但是实测并没有区别），即可在屏幕右侧或下侧看到运行效果。\n\nglsl语言与C语言glsl语言是一种C语言的变体，继承了很多C的特性，但是你想要的C的好用功能，glsl几乎都没有。当然，这得从glsl完全脱离内存讲起（这是主线，非常重要）。众所周知，GPU是一堆擅长线性计算的小学生，也就是擅长多次相似的并行计算，而非少量复杂的计算。因此，glsl语言的程序核心，对应C语言里的主函数 main，格式如下：\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )&#123;    // Normalized pixel coordinates (from 0 to 1)    vec2 uv = fragCoord/iResolution.xy;    // Time varying pixel color    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));    // Output to screen    fragColor = vec4(col,1.0);&#125;\n\n如上代码其实是Shadertoy官网上新建Shader后的示例代码。主函数 mainImage 固定输出 (注意是输出 out, 而非返回 return) 一个四维数组 fragColor表示颜色，读入一个 fragCoord表示坐标。“像素着色艺术”这个名字起得名副其实，正如主函数输入像素（坐标），输出颜色，你写代码的部分就是着色的过程，产出的就是艺术（能不能欣赏得来见仁见智）。\n回到主线，正因为glsl语言不使用内存而只用显存，所以这个主函数会被每个GPU单元、每一帧运行一次，输出的结果会先存在进程的私有寄存器内，然后等待所有线程结束后，统一将每个线程输出的fragColor存入显存里的帧缓冲区的二维数组中，最后统一传给显示器，或者参与下一帧的计算。\n因为没有内存，所以glsl语言里没有C语言的类 class（只有 struct，但是是C语言的类，不支持成员函数，另外不支持结构体数组）、地址操作（指针、取地址、解引用，申请内存，引用传参等）、输入输出操作（input&#x2F;printf等）、几乎所有隐式转换（包括任意类型向 bool的转换、int和 float的转换等），更没有 stdio.h&#x2F;stdlib.h中的绝大多数函数，C++的库更是无需多言。另外，glsl语言还不支持全局变量（const可以，详情见后）、读取前一帧Image内容（Buffer可以，详情见后）和所有非确定运行次数的代码（如 while(1)-break结构、递归调用、动态大小数组等）。现在知道C语言的方便之处了吧\n注：需要注意的是，在不同系统、不同环境中运行glsl语言的代码，可能会产生不同的结果。甚至，连glsl语言本身都有好多套不同的标准，这背后有资本的力量。有些良心系统上支持 while(1)-break等结构，但是这并不是符合所有标准的，因此还是要尽可能避免使用。\n听起来是不是极其不方便？确实，glsl上手有一定难度。不过当你逐渐熟悉这些限制之后，你会发现这门语言运行效率之高，领略GPU带来的CPU无法取代的并行计算效率，逐渐被这门语言的可视化艺术和各路高手各显神通创造的神作所折服。\n差点忘记说了，glsl语言也有自己的语法糖，用起来还算方便。 （还没有从C里面删掉的多）\n\n示例代码中的 vec2 和 vec4 就是glsl的原生数组，一共有三种: vec2&#x2F;vec3&#x2F;vec4 ，每种都默认是float数组，还有变体int数组 ivec3 ，无符号整型数组 uvec4 和bool数组 bvec2 各三种。这些数组支持比较方便的构造和访问、修改和运算操作，样例如下：\n// 构造//// 1. 直接赋值vec2 uv = vec2(0.5, 0.5);vec3 color = vec3(0.7, 0.4, 0.2);// 2. 单值填充vec3 gray = vec3(0.5); // 等效于 (0.5, 0.5, 0.5)// 3. 混合构造vec4 transparentRed = vec4(vec3(1.0, 0.0, 0.0), 0.5); // RGB + Alphavec4 rgba = vec4(color, 1.0); // 扩展为 RGBA (等效于vec4(0.7, 0.4, 0.2, 1.0))\n\n// 访问和修改//vec4 pos = vec4(1.0, 2.0, 3.0, 4.0);// 1. 标准下标（类似C数组）float x = pos[0]; // x = 1.0// 2. 分量别名（支持 .xyzw / .rgba / .stpq ，但不可混用）float y = pos.y;   // y = 2.0float a = pos.a;   // Alpha = 4.0float t = pos.t;   // 纹理坐标 t = 2.0（与 .y 相同）// 3. 链式访问（Swizzling）vec2 xy = pos.xy;  // 提取前两维 (1.0, 2.0)vec3 pos_bgr = pos.bgr; // 反转RGB通道 (3.0, 2.0, 1.0)vec4 pos_rara = pos.rara; // 允许重复提取 (1.0, 4.0, 1.0, 4.0)pos.wx = vec2(5.0, 6.0); // 修改 pos = (6.0, 2.0, 3.0, 5.0)\n\n// 运算//vec3 a = vec3(1.0, 2.0, 3.0);vec3 b = vec3(0.1, 0.2, 0.3);// 1. 逐分量运算vec3 c = a + b;    // (1.1, 2.2, 3.3)vec3 d = a * 2.0;  // 标量乘法 (2.0, 4.0, 6.0)vec3 e = a + 3.0;  // 3.0被隐式转换为 vec3(3.0), 运算结果为 (4.0, 5.0, 6.0)float dotProduct = dot(a, b); // 点积vec3 crossProduct = cross(a, b); // 叉乘// 2. 比较运算bvec3 isGreater = greaterThan(a, b); // (true, true, true)bool isEqual = (a == b); // false\nglsl语言有原生矩阵 mat2 mat3 mat4 ，还有 mat2x3 等非方阵：\n// 定义//mat2 m2 = mat2(1.0, 2.0,   // 第一 列!!               3.0, 4.0);  // 第二 列!!// 以上代码画出了矩阵：// [1.0, 3.0]// [2.0, 4.0]// 这是符合数学直觉的，但是有点反人类// n个n维向量填充定义vec3 col0 = vec3(1.0, 2.0, 3.0); // 第一列vec3 col1 = vec3(4.0, 5.0, 6.0); // 第二列vec3 col2 = vec3(7.0, 8.0, 9.0); // 第三列mat3 m3 = mat3(col0, col1, col2); // 3x3 矩阵// 也可以向量-标量混合定义mat2 m4 = mat2(1.0, 2.0,  // 第一列 (1.0, 2.0)              vec2(3.0)); // 第二列 (3.0, 0.0)// 但不可以这样！vec2 a = vec2(1.0, 2.0);vec2 b = vec2(3.0, 4.0);vec2 c = vec2(5.0, 6.0);vec3 d = vec3(7.0, 8.0, 9.0);mat3 m = mat3(a, b, c, d); // 编译错误！参数不匹配\n\n// 矩阵与矩阵运算//// 矩阵之间的加、减、乘都符合数学规则，数乘同样符合规则mat2 m = mat2(1.0, 2.0, 3.0, 4.0);mat2 mInv = inverse(m); // 逆矩阵float det = determinant(m); // 行列式 = -2.0mat2 mT = transpose(m); // 矩阵的转置\n\n// 矩阵与向量乘法//mat4 model = mat4(2.0);  // 这是左上-右下的主对角线填充2.0的对角矩阵vec4 pos = vec4(1.0, 0.0, 0.0, 1.0);  // vec会被自动认为是列向量vec4 transformed = pos * model;       // 错误！GLSL 默认不支持行向量乘法vec4 transformed = pos * transpose(model); // 正确：转为列向量乘法\n\n时间不早了，今天就先写到这吧。真希望我能够有能力和时间，把这个系列更新到完结撒花。\n欲知后事如何，且听下回分解。\n","categories":["Shadertoy"],"tags":["Shadertoy"]},{"title":"网页更新：改为ssh连接","url":"/2026/02/05/%E7%BD%91%E9%A1%B5%E6%9B%B4%E6%96%B0%EF%BC%9A%E6%94%B9%E4%B8%BAssh%E8%BF%9E%E6%8E%A5/","content":"如题，由于原本的git连接方式不够稳定，将个人网页的提交改为ssh连接了。\n调试了半个下午，每次到关键时刻，hexo d就推送不上去，给我报fatal error，这下应该彻底解决了。但愿吧。\n以后如果出现以下报错：\nfatal: unable to access &#x27;https://github.com/aaaaa114514-1/aaaaa114514-1.github.io.git/&#x27;: Recv failure: Connection was reset\n\n说明网络环境发生变化，需要先在终端中输入：\nssh -T git@github.com\n\n验证身份后方可推送hexo d.\n","categories":["建站"],"tags":["Website_building"]},{"title":"从零开始的Shadertoy生活_02","url":"/2025/06/30/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Shadertoy%E7%94%9F%E6%B4%BB_02/","content":"02 glsl 语言：内置参数，函数与常量在上一章中，我们已经充分了解了glsl语言与C语言的异同。这一章将接着上一章的内容，继续补充完善glsl语言的内置函数与常量。在介绍完常量过后，我们将进一步了解内置参数。\n内置函数glsl的内置函数有很多，在此无法一一列举，仅对最常用、最通用的函数进行介绍。（若想全面、深刻了解glsl语言，请参考 OpenGL相关标准 ）\n数学计算函数// 三角相关radians(degrees)    // 角度转弧度degrees(radians)    // 弧度转角度sin(x), cos(x), tan(x)\t\t  // 三角函数asin(x), acos(x), atan(x)  \t  // 反三角函数sinh(x), cosh(x), tanh(x)     // 双曲函数// 指对幂pow(x, y)      // 指数 x^yexp(x)         // e指数 e^xexp2(x)        // 2指数 2^xlog(x)         // ln(x)log2(x)        // log2(x)sqrt(x)        // 平方根inversesqrt(x) // 1/sqrt(x)// 整数相关abs(x)        // 绝对值sign(x)       // 符号函数（-1, 0, 1）floor(x)      // 向下取整ceil(x)       // 向上取整round(x)      // 四舍五入trunc(x)\t  // 截断到整数fract(x)      // 小数部分（x - floor(x)）mod(x, y)     // 浮点数取模 (正整数为x % y)min(x, y), max(x, y)  // 最小/最大值clamp(x, min, max)    // x在min以下时返回min，在max以上时返回max，其余直接返回xmix(x, y, a)  // 线性插值（x*(1-a) + y*a）step(edge, x) // x &gt;= edge ? 1 : 0smoothstep(edge0, edge1, x) // x在edge0及以下时返回0，在edge1及以上时返回1，中间平滑差值（3次Hermite差值）\n\n注意事项：\n\n以上所有运算均可应用于 vec ，效果等同于对每一项分别操作。\n三角函数、反三角函数默认使用弧度制。\npow 函数对于负数的非整数次方返回值不定（这是Undefined Behavior）。\nmod 函数不能用于整数，整数请用 a % b 计算。\nmod(x, y) = x - y * floor(x / y) ，即取模结果与y同号。\nmin max clamp 会返回更宽的类型，即 min(float, int) -&gt; float max(vec3, float) -&gt; vec3 。\n\n// 向量相关length(x)     // 向量模长distance(p0, p1)  // 两点距离dot(x, y)     // 点积cross(x, y)   // 叉积normalize(x)  // 归一化向量，返回对应单位向量reflect(I, N) // 反射向量（I 为入射，N 为法线）refract(I, N, eta) // 折射向量（eta 为折射率）faceforward(N, I, Nref) // 确保法线 N 最终朝向与参考方向 Nref 相反的一侧any(x)  // 任意分量为真则返回 trueall(x)  // 所有分量为真则返回 truelessThan(x, y), greaterThan(x, y)  // 分量逐项比较\n\n注意事项：\n\n叉乘 cross 仅适用于 vec3 。\nreflect 和 refract 的 I 与 N 参数都需要归一化。\nreflect(I, N) = I − 2 * (N ⋅ I) * N 。\n折射 refract 符合斯涅耳定律，全反射时返回反射角方向。\n\n// 矩阵相关transpose(M)      // 转置矩阵determinant(M)    // 行列式（仅适用于方阵）inverse(M)       // 逆矩阵（仅适用于方阵）outerProduct(c, r) // 外积（生成矩阵）\n\n注意事项：\n\n仅部分高版本（GLSL 3.30+（OpenGL 3.3+））支持非方阵（如 mat2x3 ），但是计算消耗大于方阵，因此尽可能少使用非方阵。\n\n以上数学函数将贯通整个 Shader 学习过程，请熟记于心（记不住也没关系，多写自然熟练）。\ntexture 相关纹理函数由于纹理比较复杂，此处暂且按下不表，后面会单独开一个章节讨论纹理和缓冲（Buffer）。\n常量学过C语言的同学都知道，常量就是 const ，声明必须同时定义，一旦定义就不能修改。如果真的这么简单，那根本没必要单开一节来讨论常量\nglsl中大致符合以上标准的“常量”共有3种：const #define 和 uniform ， 我们一个个看。\nconst：真正的“常量”和C语言中的一样，const常量是真正的“常量”，在作用域内保持值不可变。如果定义在主函数或是其他某个函数内部，那么const常量将在每次调用这个函数的时候被定义，生命周期持续到函数结束；如果定义在全局（即写在所有函数外面），const常量将仅在编译开始后定义一次，每帧不再重新定义。\n// 全局 const（全局只定义一次）const vec3 c_sky = vec3(0.53, 0.81, 0.92);void mainImage( out vec4 fragColor, in vec2 fragCoord )&#123;    // 归一化像素    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);      // 局部 const（每次调用 mainImage 函数时重新定义）    const vec3 ORANGE = vec3(1.0, 0.4, 0.0);    fragColor = vec4(mix(c_sky, ORANGE, uv.y * 0.7), 1.0);&#125;\n\n#define：“常”而非“量”和C语言中的一样，#define 是预处理器指令，在编译之前就直接做文本替换，不消耗空间，几乎不影响运行效率。所以这不是一种“量”，只是一种宏定义的别名。相比于const，#define 不会进行类型检查，也就是不会被编辑器的红色波形曲线发现，但有可能造成 Compile Error。\n#define PI 3.1415926538#define TWO_PI 6.28318530718  // 2 * PIvoid mainImage(out vec4 fragColor, in vec2 fragCoord) &#123;    // 归一化像素坐标到 [0, 1] 并居中    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);      // 计算极坐标（半径和角度）    float radius = length(uv);    float angle = atan(uv.y, uv.x);      // 使用 PI 控制圆环的周期性（每 PI/2 弧度变换一次颜色）    float colorMask = sin(angle * 4.0 + radius * 10.0);  // 4.0 = 2*PI/(PI/2)      // 生成彩虹色    vec3 rainbow = 0.5 + 0.5 * cos(angle + vec3(0.0, TWO_PI/3.0, TWO_PI*2.0/3.0));      // 圆环效果（内半径 0.3，外半径 0.4）    float ring = smoothstep(0.3, 0.31, radius) - smoothstep(0.4, 0.41, radius);      // 混合颜色和圆环    fragColor = vec4(rainbow * ring * colorMask, 1.0);&#125;\n\nuniform：“量”而不“常”uniform是glsl有别于C的一大特性：它用于传输从宿主程序（如 CPU）向着色器传递的运行时不可变的全局数据。换句话说，uniform常量是CPU向GPU传递数据的单向管道。uniform常量将保持在运行时不变，也就是说在同一帧内每个像素点运行主函数时保持不变且不可修改；但是在不同帧运行之前，CPU可以修改传入的uniform的值。因此，uniform常量不是真正的“常”量。一些常见的uniform常量将在下一节：内置参数中给出。\n注：由于自定义uniform常量将涉及到OpenGL API在CPU端修改配置（主要是作者不会），本系列暂不考虑，仅讨论Shadertoy内制的uniform参数。\n内置参数新建一个Shadertoy在线着色器，点开代码区顶部的“着色器输入”，你会发现这些内置参数：\nuniform vec3      iResolution;           // viewport resolution (in pixels)uniform float     iTime;                 // shader playback time (in seconds)uniform float     iTimeDelta;            // render time (in seconds)uniform float     iFrameRate;            // shader frame rateuniform int       iFrame;                // shader playback frameuniform float     iChannelTime[4];       // channel playback time (in seconds)uniform vec3      iChannelResolution[4]; // channel resolution (in pixels)uniform vec4      iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: clickuniform samplerXX iChannel0..3;          // input channel. XX = 2D/Cubeuniform vec4      iDate;                 // (year, month, day, time in seconds)\n\n根据我们对 uniform 常量的了解，我们知道，这是每一帧CPU将要传递给GPU的数据。\n","categories":["Shadertoy"],"tags":["Shadertoy"]},{"title":"网页更新：文章分类","url":"/2026/02/05/%E7%BD%91%E9%A1%B5%E6%9B%B4%E6%96%B0%EF%BC%9A%E6%96%87%E7%AB%A0%E5%88%86%E7%B1%BB/","content":"个人网页更新了文章分类功能！\n为什么要更新这个功能呢？因为正在开新坑零基础速通系列的时候，发现标题级别不够用了，全都混在一起会导致目录无法覆盖所有级别的标题，然后文字全部混在一起看不清的情况。所以，我决定把一篇文章拆开成几个部分来写，方便读者阅读。\n记录一下添加分类的过程：\n\n先在本地个人网页的根目录下打开终端，输入 hexo new page categories，然后在 /source/categories目录下就会自动有新文件 index.md；\n\n把这个 index.md文件内容改为以下：\n---title: 分类 | Categoriesdate: 2026-02-05 15:57:27type: &quot;categories&quot;layout: &quot;categories&quot;comments: false---\n\n这样，分类的页面就配置好了；\n\n接下来要配置导航栏的“分类”标签：在 _config.redefine.yml文件中配置 navbar的 links项目中添加以下代码：\ncategories:  path: /categories  icon: fa-regular fa-folders\n\n这样首页栏上就会有分类的选项和图标了！\n\n最后，不要忘记给每篇文章一个分类位置，具体操作就是在文章的配置栏里添加一个 categories字段。注意分类是可以像文件夹一样嵌套的，比如：\n---title: 文章标题date: 2026-02-05 17:00:00categories:- 父目录- 子目录tags: 文章标签---\n\n这样，分类功能就配置好了！\n\n\n这次更新顺便整理了一下以前的文章标题。\n","categories":["建站"],"tags":["Website_building"]},{"title":"网页更新：添加友链","url":"/2025/05/19/%E7%BD%91%E9%A1%B5%E6%9B%B4%E6%96%B0%EF%BC%9A%E6%B7%BB%E5%8A%A0%E5%8F%8B%E9%93%BE/","content":"添加了友链功能。\n记录一下操作：\n\n打开 aaaaa_online\\source\\_data\\links.yml ，添加以下内容：\n\n - name:  # Name\n   link:  # Friend&#39;s link\n   description:  # Individual signiture\n   avatar:  # Photo\n\n\n\n\n编辑姓名、友链、个签、头像；\n\n上传！\n\n\n","categories":["建站"],"tags":["Website_building"]},{"title":"网页更新：添加BGM","url":"/2025/05/19/%E7%BD%91%E9%A1%B5%E6%9B%B4%E6%96%B0%EF%BC%9A%E6%B7%BB%E5%8A%A0BGM/","content":"向主页添加了第一首歌，然后又添加了4首。\n记录一下操作：\n\n打开 aaaaa_online\\_config.redefine.yml 找到 plugins/aplayer/audios ，复制一份如下代码：\n\nartist: 葉月ゆら # audio artist\nurl: /music/HAMELN.mp3 # audio url\ncover: /images/cover/HAMELN.png # audio cover url\nlrc: # audio cover lrc\n\n\n\n\n更改作者、曲名；\n\n在 aaaaa_online\\node_modules\\hexo-theme-redefine\\source\\music 目录下保存一份 mp3 ，在 aaaaa_online\\node_modules\\hexo-theme-redefine\\source\\images\\cover 目录下保存一份背景图；\n\n上传！\n\n\n这个播放器插件声音有点大，而且没办法调节声音大小，略显不方便。以后找机会换一个能调声音大小的。\n","categories":["建站"],"tags":["Website_building"]},{"title":"网页更新：第一步","url":"/2025/05/17/%E7%BD%91%E9%A1%B5%E6%9B%B4%E6%96%B0%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AD%A5/","content":"个人网页终于建出来了！感谢 Arahc 的帮助！\n友情链接：  Arahc&#39;s Home - A simple blog site.\n时间不早了，今天测完网页就睡。\n记录一下操作：\n\n$ hexo clean 清除generate的内容;\n$ hexo g generate: 生成基于新的内容的 bulider;\n$ hexo s server: 开启本地服务器，用于测试;\n(默认在 http://localhost:4000/ 打开本地测试)\n\n\n$ hexo d deploy: 部署到网页，发布到公网。\n\n在 Github仓库 可以看到上传的内容与上传的进度。由于上传很慢，所以要本地测试后再上传。\n注：每篇文章都要复制前一篇文章的 Markdown 文件，否则可能由于格式细节而无法识别！\n","categories":["建站"],"tags":["Website_building"]},{"title":"网页更新：脚本提交","url":"/2026/02/12/%E7%BD%91%E9%A1%B5%E6%9B%B4%E6%96%B0%EF%BC%9A%E8%84%9A%E6%9C%AC%E6%8F%90%E4%BA%A4/","content":"hexo提交又双叒叕遇到问题了。\n这次怎么传都传不上去，但是github网页能登录，而且ping也是通的。\n现在彻底放弃hexo提交了，改用一段脚本deploy.ps1来提交。\n现在只需要在aaaaa_online目录下打开命令行，输入：\n.\\deploy.ps1\n\n即可完成hexo clean + hexo g + hexo d的所有功能。\n附上deploy.ps1的源代码：\nhexo cleanhexo generateSet-Location -Path .\\publicif (!(Test-Path &quot;.git&quot;)) &#123;    git init&#125;$remoteName = &quot;origin&quot;$remoteUrl = &quot;git@github.com:aaaaa114514-1/aaaaa114514-1.github.io.git&quot;if (git remote | Select-String $remoteName) &#123;    git remote remove $remoteName&#125;git remote add $remoteName $remoteUrlgit add .git commit -m &quot;Deploy: $(Get-Date -Format &#x27;yyyy-MM-dd HH:mm:ss&#x27;)&quot;git branch -M maingit push -u origin main --forceSet-Location -Path ..Write-Host &quot;Deploy Done!&quot;\n\n","categories":["建站"],"tags":["Website_building"]},{"title":"零基础速通系列开坑","url":"/2026/02/05/%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9F%E9%80%9A%E7%B3%BB%E5%88%97%E5%BC%80%E5%9D%91/","content":"随着课程难度逐渐上升，感觉光凭脑子和纸质笔记可能应付不过来了，于是打算就此开坑 零基础速通 系列，边学边记，一方面方便后来者（如果有的话，哈哈）少走弯路，另一方面则是方便我自己随时回来查找。这个系列估计真的会长期更新，本打算一门课写在一篇里的，奈何一整篇文章的标题层级实在太多，放在网页上放不下了，于是改为每门课在零基础速通分类下建立一个文件夹来存储。\n本篇作为编写日志兼目录，计划长期更新！\nCS130 操作系统I","categories":["零基础速通"],"tags":["0_Start_Learning"]},{"title":"CS130 操作系统I 课程介绍","url":"/2026/02/02/%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9F%E9%80%9A%EF%BC%9ACS130%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FI_1/","content":"对于完全没有操作系统经验的笔者而言，这节课确实零基础开始。根据前人留下的珍贵数据资料，这节课的双人Project占总Workload占比极大，因此从寒假开始先做起来。在此特别感谢向我提供教程的同学，以及编写和改编教程的所有程序员和工程师们。\n参考教程\n校内课程要求：CS130 - Operating Systems （需要校内VPN访问）\nPintos北大教程：Pintos\n一份关键的非官方代码教程：Pintos+Guide\n\n\n回到目录\n","categories":["零基础速通","CS130 操作系统I"],"tags":["0_Start_Learning"]},{"title":"CS130 操作系统I 理论部分","url":"/2026/02/02/%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9F%E9%80%9A%EF%BC%9ACS130%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FI_2/","content":"[还没上课，暂略]\n\n回到目录\n","categories":["零基础速通","CS130 操作系统I"],"tags":["0_Start_Learning"]},{"title":"CS130 操作系统I Project 0 准备工作","url":"/2026/02/04/%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9F%E9%80%9A%EF%BC%9ACS130%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FI_3/","content":"Project: 基于PintOS的手搓操作系统！整个学期的Project分为5个部分：\n\nProject 0: 准备工作\nProject 1: Threads | 线程\nProject 2: User Programs | 用户程序\nProject 3: Virtual Memory | 虚拟内存\nProject 4: File Systems | 文件系统\n\n每个部分基于前一个部分的工作完成，所以还请务必按照顺序！\n学期内的Project是在学校的在线平台上完成，那里已经搭好了VM的环境，需要ssh远程过去写代码、跑调试。但是在假期内学校在线端口无法访问，Project需要通过在本地手动配置环境并部署来完成。接下来介绍的所有过程都基于本地Windows 11系统，从头开始配置环境、部署Project。\n\nProject 0: 准备工作安装与调试由于我是Windows 11用户，之前听说在Windows上不能安装Docker，但是发现了Docker Desktop过后，Windows上也能轻松使用Docker了。虽然说本质上还是一种WSL(Windows Subsystem for Linux)，但是省得我装一个VMWare或者直接在本机上装一个Ubuntu(事实上我都装了，希望后来者可以不用走这条弯路)。具体步骤如下：\n安装Docker从官网链接下载，非苹果机的Windows用户选择 Download for Windows - AMD64，下载后按照提示正常安装即可；安装完成后打开，可能会出现要求安装WSL的命令行窗口，按任意键安装，大约需要3-5min完成；\n下载PintOS源代码包有两种方法：①按照学校提供的链接下载并解压（需要校内VPN访问），或者②从北大的Github仓库下拉：\ngit clone git@github.com:PKU-OS/pintos.git\n\n在本地进行系统测试打开Decker Desktop客户端，打开系统的命令行窗口，完成如下对话：\n\n将以下输入路径调整成实际安装路径后输入：\ndocker run -it --rm --name pintos --mount type=bind,source=absolute/path/to/pintos/on/your/host/machine,target=/home/PKUOS/pintos pkuflyingpig/pintos bash\n\n然后命令行应该会变成如下格式（具体内容可能不同）：\nps. 如果提示 fail to connect to the docker API，可以尝试挂梯子使用（先打开Decker Desktop）\nroot@9113da5c984f:~#\n\n这说明一个微型的Ubuntu系统正在你的电脑上运行！\n\n接下来键入：\npwd\n\n会有如下回话：\n/home/PKUOS\n接下来键入：\nls\n\n会有如下回话：\npintos  toolchain\n以上对话如果均正常，那么接下来可以尝试启动系统了，键入：\ncd pintos/src/threads/makecd buildpintos --\n\n如果回话的最后几行类似于：\nPintos hda1Loading............Kernel command line:Pintos booting with 3,968 kB RAM...367 pages available in kernel pool.367 pages available in user pool.Calibrating timer...  32,716,800 loops/s.Boot complete.\n\n那就说明你的PintOS系统在本地成功运行了！\n\n注：此时可以按 Ctrl + C关闭PintOS系统，然后按 Ctrl + D退出微型的Ubuntu系统。\n\n目前已经完成的架构，是在Windows上通过WSL和Docker建立了一个Ubuntu容器(Container)，然后在这个Ubuntu容器内部通过QEMU模拟了一台x86计算机的硬件结构，然后在这台模拟的计算机上运行了PintOS系统，这个结构画出来就是这样的：\nHost OS（Windows / macOS / Linux）└── Docker    └── Ubuntu Linux（容器里的用户态 Linux）        └── QEMU（一个普通用户程序）            └── 模拟的 32-bit x86 计算机（CPU, 内存, 磁盘等硬件）                └── PintOS（操作系统）\n\n在本地进行程序测试尝试运行Project 1的本地test：\n\n打开任意终端，启动Ubuntu系统：\ndocker run -it --rm --name pintos --mount type=bind,source=absolute/path/to/pintos/on/your/host/machine,target=/home/PKUOS/pintos pkuflyingpig/pintos bash\n\nroot@9113da5c984f:~#\n进入 pintos/src/threads/build/目录：\ncd pintos/src/threads/build/\n\nroot@4aedfa24dc44:~/pintos/src/threads/build#\n开始测试：\nmake check\n\n测试大约需要20~30s，看到输出结果最后类似于以下，说明你到目前为止的操作没有问题：\npass tests/threads/alarm-singlepass tests/threads/alarm-multiplepass tests/threads/alarm-simultaneousFAIL tests/threads/alarm-prioritypass tests/threads/alarm-zeropass tests/threads/alarm-negativeFAIL tests/threads/priority-changeFAIL tests/threads/priority-donate-oneFAIL tests/threads/priority-donate-multipleFAIL tests/threads/priority-donate-multiple2FAIL tests/threads/priority-donate-nestFAIL tests/threads/priority-donate-semaFAIL tests/threads/priority-donate-lowerFAIL tests/threads/priority-fifoFAIL tests/threads/priority-preemptFAIL tests/threads/priority-semaFAIL tests/threads/priority-condvarFAIL tests/threads/priority-donate-chainFAIL tests/threads/mlfqs-load-1FAIL tests/threads/mlfqs-load-60FAIL tests/threads/mlfqs-load-avgFAIL tests/threads/mlfqs-recent-1pass tests/threads/mlfqs-fair-2pass tests/threads/mlfqs-fair-20FAIL tests/threads/mlfqs-nice-2FAIL tests/threads/mlfqs-nice-10FAIL tests/threads/mlfqs-block20 of 27 tests failed.../../tests/Make.tests:26: recipe for target &#x27;check&#x27; failedmake: *** [check] Error 1\n\n完成！至此，你的安装和调试过程就已经全部完成了！\n\n建库与合作由于项目很大很难，所以强烈建议用Github完成：这样一方面完成了团队合作，另一方面也做了版本控制。仓库需要一定的管理，否则极容易发生混乱。建议的管理方式如下：\n\n初始仓库内仅有原始的PintOS源代码，存在 main分支下；\n每次开始一个新的Project时，继承上一个project的分支，建立新的分支，然后在新的分支内完成代码编写；\n待上一个Project代码稳定后，保证代码不再修改后再建立新的分支，开始下一个Project，同时把旧分支内容合并到main分支，以达到提交目的；\n项目完成前，clone整个仓库到本地，测试其中main分支的内容，确保能够通过所有测试点。\n\n记得频繁Commit！这样可以有效减少合作冲突！\n由于笔者记不太住Git命令，所以在此附上常用的命令：\n\ngit status 查看仓库状态\ngit branch 查看当前在哪个分支下\ngit checkout proj1_threads 进入本地仓库已有的分支 proj1_threads\ngit checkout -b proj1_threads 复制当前分支所有内容进入新分支 proj1_threads，并进入新分支\ngit pull 拉取当前分支下所有内容\ngit add . 添加本地目录下所有文件进入暂存区\ngit commit -m &quot;comments&quot; -m &quot;description&quot; 提交暂存区内容到本地仓库（引号是命令的一部分）\ngit push -u origin proj1_threads 将本地仓库当前分支内容推送到远端仓库新建分支 proj1_threads（请保证本地仓库与远端仓库名称一致！）\ngit push 将本地仓库当前分支内容推送到远端仓库对应的分支上\ngit merge proj1_threads 在本地仓库，把proj1_threads分支的内容合并到当前分支\n\n\n评分标准以下的评分标准是基于Stanford课程代码标准的、针对四个Project的评分标准，也同样是往年CS130课程采用的评分标准。\n总体标准每个项目在百分制下，分为以下得分点：\n\n40% - 成功通过源文件中已经给出的所有样例测试点\n10% - 成功通过未给出的测试用数据点\n10% - 一份完整的设计文档\n15% - 代码整洁程度、可读性、注释\n5% - 符合Git提交要求\n20% - 线下的Code check\n\n所有项目不可迟交！\n出分后一周内可以argue得分。\n设计文档\n使用每个项目独立的设计文档模板：\nProject 1: Threads | 线程\nProject 2: User Programs | 用户程序\nProject 3: Virtual Memory | 虚拟内存\nProject 4: File Systems | 文件系统\n\n\n需要另外简要介绍项目分工情况\n将文本整理成pdf格式，提交Gradescope并署团队所有人的名字\n格式不必严格按照模板，只要便于理解，甚至可以插入图片\n评分为三档制：10% &#x2F; 7% &#x2F; 4%\n\n代码要求\n建议遵循Stanford课程代码标准，也可以有自己的码风\n所有代码码风必须统一\n评分为三档制：15% &#x2F; 10% &#x2F; 5%\n\nGit提交要求\n禁止使用-f指令强制提交(force push)\n在项目完成前，每两次commit时间间隔不大于7天；项目可以在ddl前任意时间完成\n每个项目的第一次commit时间不晚于上一个项目结束后7天\nGithub检查代码时，仅检查main分支下的代码，故每次完成项目时，需将代码从工作分支合并到main分支\n\nCode check\n主要检查代码原创性和对代码的掌握程度\n大约10分钟，一般安排在ddl后一天\n所有团队成员都要到场\n助教会问4个问题，每个问题占 5% 分值\n\n\n需要了解的内容Pintos 目录简介\nthreads/\n基础内核的源代码，从Project 1开始你将修改此部分。\n\n\nuserprog/\n用户程序加载器的源代码，从Project 2开始你将修改此部分。\n\n\nvm/\n一个几乎为空的目录。你将在Project 3中在此实现虚拟内存。\n\n\nfilesys/\n基础文件系统的源代码。从Project 2开始你将使用此文件系统，但直到Project 4才会修改它。\n\n\ndevices/\nI&#x2F;O设备接口的源代码：键盘、计时器、磁盘等。你将在Project 1中修改计时器实现。除此之外，你无需更改此部分。\n\n\nlib/\n标准C库子集的实现。从此目录编译的代码从Project 2开始会同时被编译进Pintos内核及其下运行的用户程序中。在内核代码和用户程序中，均可使用 #include &lt;...&gt;符号包含此目录中的头文件。你基本不需要修改此部分。\n\n\nlib/kernel/\n仅包含在Pintos内核中的C库部分。同时包含了一些你可以在内核代码中自由使用的数据类型的实现：位图、双向链表和哈希表。在内核中，可以使用 #include &lt;...&gt;符号包含此目录中的头文件。\n\n\nlib/user/\n仅包含在Pintos用户程序中的C库部分。在用户程序中，可以使用 #include &lt;...&gt;符号包含此目录中的头文件。\n\n\ntests/\n各项目的测试代码。如果有助于测试你的提交，你可以修改此处的代码。评分时，在运行测试前会将 tests/目录替换为原始版本。\n\n\nexamples/\n从项目2开始使用的示例用户程序。\n\n\nmisc/和 utils/\n如果你尝试在自己的机器上使用Pintos，这些文件可能会派上用场。否则，你可以忽略它们。\n\n\n\n更详细内容请参阅：Build and Run | Pintos\nBuild要构建项目，只需要 cd进入某个项目目录（如 threads/, userprog/, vm/, filesys/等），然后键入指令：\nmake\n\n等待20~30s即构建完成！\n有关构建项目产生的文件具体用途，更详细内容请参阅：Building Pintos | Pintos\nRun要执行指令，可以按照以下规则输入指令：\npintos [工具选项] -- [内核参数]\n\n其中，[工具选项] 部分为可选项（可以不写，也可以串接写很多个）：\n\n--bochs 使用Bochs代替默认的Qemu来模拟计算机；Bochs更适合Debug时使用，而Qemu大多数情况下跑得更快\n--gdb 用Debug模式运行\n-m 128 设置内存大小为128MB\n-v 关闭VGA显示，仅输出结果\n--bochs -t 使用终端作为VGA显示\n-s 禁用输入输出，避免交互，仅输出结果\n\n[内核参数] 部分可以有如下内容：\n\nrun alarm-multiple 指将 run alarm-multiple 作为参数传给PintOS系统，由系统响应这个指令，即运行指定的测试：alarm-multiple\n\n所以总体上一个合法的输入可以是：\npintos -v -- run alarm-multiple\n\n要想关闭进程，可以 Ctrl + C强制停止。\n另外，获取更全的参数表可以键入：\npintos -h\n\n更详细内容请参阅：Running Pintos | Pintos\nTest现在似乎只能一次性测试所有数据点，不过功能上完全覆盖测试单个数据点，只不过测试时间略长一点。测试过程如下：\n\n先完成项目构建，然后进入项目目录：\ncd pintos/src/threads/build\n跑测试：\nmake check\n测试结果会直接显示出来，每个数据点具体的错误信息保存在具体项目目录下，如 pintos/src/threads/build/tests/threads等\n\n从第二次测试开始，每次测试之前需要先手动删除该文件夹，如 pintos/src/threads/build/tests/threads等\n\n\npintos/src/tests下的各个目录分别代表各个项目的测试程序目录，其中存有评测数据生成器和评测机等；可以手动修改部分评测机数据点进行本地测试，不过最终会以原数据点结果计分。\n更详细的内容请参阅：Testing | Pintos\nDebug支持使用 printf()和 ASSERT来辅助Debug。\n可以使用 Backtrace来Debug，具体操作详见Debugging | Pintos.\n使用GDB来Debug:\n\n先正常启动Docker，然后在 终端1上启动Ubuntu系统；\n\n打开 终端2，键入：\ndocker exec -it pintos bash\n\n这样就成功在两个终端上进入同一个Ubuntu容器了。\n\n接下来在 终端1上先 make构建项目，然后进入项目目录（如 pintos/src/threads），键入带 --gdb选项的运行指令，如：\npintos --gdb -- run alarm-multiple\n\n然后 终端1会进入gdb模式，显示类似于这样的内容：\nqemu-system-i386 -device isa-debug-exit -drive format=raw,media=disk,index=0,file=/tmp/2yFkc39zD1.dsk -m 4 -net none -nographic -gdb tcp::1234 -S\n接下来在 终端2上进入项目目录中的 build文件夹（如 pintos/src/threads/build），键入：\ngdb kernel.o\n\n此时 终端2就成功进入gdb模式了，显示类似于这样的内容：\nGNU gdb (Ubuntu 8.1.1-0ubuntu1) 8.1.1Copyright (C) 2018 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later \t&lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute \tit.There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-linux-gnu&quot;.Type &quot;show configuration&quot; for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type &quot;help&quot;.Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...Reading symbols from kernel.o...done.(gdb)\n接下来在 终端2中键入：\ntarget remote localhost:1234\n\n此时 终端2成功连接上本机端口1234，显示类似于这样的内容：\nRemote debugging using localhost:12340x0000fff0 in ?? ()(gdb)\n\n这样gdb的配置就完成了。\n\n接下来就可以在 终端2上调试代码了。以下是一些gdb调试指令：\n\n程序控制\n\nc &#x2F; continue继续运行程序\nsi单步执行一条汇编指令\nni单步执行一条汇编指令（不进入调用）\ns &#x2F; step单步执行一行源码（进入函数）\nn &#x2F; next单步执行一行源码（不进入函数）\nfinish运行到当前函数返回\nquit退出 GDB\n\n\n断点\n\nb &lt;function&gt;在函数入口设置断点\nb &lt;file&gt;:&lt;line&gt;在指定文件行号设置断点\ninfo break查看所有断点\ndisable &lt;n&gt;禁用编号为 n 的断点\nenable &lt;n&gt;启用编号为 n 的断点\ndelete &lt;n&gt;删除编号为 n 的断点\ndelete删除所有断点\n\n\n调用栈 &#x2F; 执行上下文\n\nbt显示调用栈（backtrace）\nframe &lt;n&gt;切换到第 n 层栈帧\ninfo frame查看当前栈帧信息\n\n\n变量 &#x2F; 表达式\n\np &lt;expr&gt;打印变量或表达式\np/x &lt;expr&gt;以十六进制打印\nset var &lt;var&gt;=&lt;value&gt;修改变量值\ninfo locals查看当前函数的局部变量\ninfo args查看当前函数参数\n\n\n寄存器\n\ninfo registers查看所有寄存器\ninfo registers eip esp ebp查看指定寄存器\np $eip打印寄存器值\n\n\n内存 &#x2F; 指令查看\n\nx/10i $eip查看当前指令地址开始的 10 条汇编\nx/16x &lt;addr&gt;以十六进制查看内存\nx/4w &lt;addr&gt;以 word 形式查看内存\ndisassemble &lt;function&gt;反汇编函数\n\n\n源码查看\n\nlist显示当前源码附近\nlist &lt;function&gt;显示函数源码\nlist &lt;file&gt;:&lt;line&gt;显示指定位置源码\n\n\n线程\n\ninfo threads查看所有线程\nthread &lt;n&gt;切换到指定线程\n\n\n\n\n终端2退出：键入 quit或按下 Ctrl + D，并确认退出\n\n终端1退出：可以先按下 Ctrl + A，松开后再按下 X关闭进程\n\n\n更详细的内容请参阅：Debugging | Pintos\n评分自测在Ubuntu系统内、项目目录下（如 pintos/src/threads），在构建、运行结束后，可以键入：\nmake grade\n\n以自动计算当前结果对应的分数和每个测试点的详细得分情况。\n更详细的内容请参阅：Grading | Pintos\n\n至此，Project 0，即写代码之前的必要准备就已经全部完成了！准备迎接代码之旅吧！\n\n回到目录\n","categories":["零基础速通","CS130 操作系统I"],"tags":["0_Start_Learning"]},{"title":"CS130 操作系统I Project 1 Threads | 线程","url":"/2026/02/05/%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9F%E9%80%9A%EF%BC%9ACS130%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FI_4/","content":"Project 1 是关于Threads，也就是线程的。这是整个PintOS学习之旅的第一站！\n首先，下载设计文档模板，按照模板填写。有时候，模板真的能提供不少动力和思路。（当然是为了交作业）\n如果你第一次不知道怎么填，可以参考这个。\n接下来我们正式开始代码工作！\n\n文件介绍threads目录下的文件接下来pintos/src/threads路径下的24个代码文件（除去.gitignore Makefile Make.vars等仓库和作业配置文件）会大致按照代码的调用顺序一一介绍：\n\nloader.S loader.h\n\n这是一个只有512字节的内核加载器程序，由BIOS加载，负责在磁盘上定位操作系统内核，然后把这个内核加载到内存里，并跳转执行内核start.S中的start()函数。\n不用看懂，不要修改。\n\n\nkernel.Ids.S\n\n连接内核的链接程序。\n设置了内核的加载地址，安排start.S在内核镜像最前端附近。\n不用看懂，不要修改。\n\n\nstart.S\n\n为32位操作系统的运行提供基础环境。\n这不属于加载器，而是内核的一部分。\n不用看懂，不要修改。\n\n\ninit.c init.h\n\n内核初始化程序，其中main()函数（或pintos_init()函数）是整个内核的主函数。\n需要至少理解初始化过程每一步初始化了什么，可能需要增加自定义的初始化代码。\n\n\nthread.c thread.h\n\n线程相关的主要代码文件。\nthread.h文件中关于struct thread的定义很有可能在四个Project中都会修改。\n需要理解绝大多数代码含义，需要大量增添或修改代码。\n\n\nswitch.S switch.h\n\n用汇编语言直接控制CPU实现的线程切换。\n这是线程底层实现，不涉及控制何时切换线程。\n不用看懂，不要修改。\n\n\npalloc.c palloc.h\n\n这是页分配器(Page ALLOCator)，负责以页（每页是4kB）为单位向系统分配内存（只能是整数页）。\n需要理解代码目的，不用修改。\n\n\nmalloc.c malloc.h\n\n这是内核代码中malloc()函数和free()函数的简单实现。\n需要理解代码目的，不用修改。\n\n\ninterrupt.c interrupt.h\n\nCPU中断的基础处理代码。\n管理中断与分发相关底层内容，不涉及调度策略。\n需要理解代码目的，不用修改。\n\n\nintr-stubs.S intr-stubs.h\n\n处理中断的底层汇编代码。\n不用看懂，不要修改。\n\n\nsynch.c synch.h\n\n定义了基本同步原语（primitive, 指从当前考虑的操作系统层面上看，不可继续细分的单元结构）：\nsemaphore | 信号量\nlock | 线程锁\ncondition variable | 条件变量\noptimization barrier | 优化屏障\n\n\n在四个Project中均会用到。\n需要看懂，需要修改。\n\n\nio.h\n\n输入输出I&#x2F;O端口连接相关函数。\n不用看懂，不要修改。\n\n\nvaddr.h pte.h\n\n处理虚拟地址和页表项的相关函数和宏定义。\n在Project 3之前不需要看懂和修改。\n\n\nflags.h\n\n标志寄存器的一些标志的宏定义。\n不用看懂，不要修改。\n\n\n\ndevices目录下的文件接下来介绍pintos/src/devices目录下的24个代码文件：\n\ntimer.c timer.h\n系统计时器，默认每秒100次中断\n需要看懂，需要修改。\n\n\nvga.c vga.h\n控制终端的输出，printf()会调用这里的内容。\n不用看懂，不要修改。\n\n\nserial.c serial.h\n串口驱动，与输入输出相关。\n不用看懂，不要修改。\n\n\nblock.c block.h\n块设备抽象层。\n将磁盘抽象为块（定长数组）。\n在Project 2之前不需要看懂和修改。\n\n\nide.c ide.h\n支持IDE硬盘扇区的直接读写。\n不用看懂，不要修改。\n\n\npartition.c partition.h\n硬盘分区相关代码。\n不用看懂，不要修改。\n\n\nkbd.c kbd.h\n键盘驱动，控制键盘的输入。\n不用看懂，不要修改。\n\n\ninput.c input.h\n输入层，控制输入队列。\n不用看懂，不要修改。\n\n\nintq.c intq.h\n中断队列，管理线程和中断都能安全访问的循环队列。\n不用看懂，不要修改。\n\n\nrtc.c rtc.h\n读取当前日期和时间。\n默认仅供pintos/src/threads/init.c中随机数生成器的初始种子使用。\n不用看懂，不要修改。\n\n\nspeaker.c speaker.h\n蜂鸣器驱动。\n不用看懂，不要修改。\n\n\npit.c pit.h\n8254可编程定时器的代码。\n仅由timer.c和speaker.c调用的底层代码。\n不用看懂，不要修改。\n\n\n\nlib目录下的文件lib和lib/kernel包含了许多C语言的库函数，以供编程时调用；而lib/user中包含了用户程序可能用到的内容，在Project 2中才会用到。\n具体文件不再一一列举，不过有以下内容需要了解：\n\n&lt;string.h&gt;和&lt;stdio.h&gt;下的部分字符串相关函数由于其安全性问题，被踢出了这次lib的C标准库。详情见此处。\nkernel/list.c kernel/list.h 可能会在Project 1中使用到。\n\n更详细的内容请参阅：Background | Pintos\n\n任务要求与执行建议任务要求\n在devices/timer.c中重构timer_sleep()的实现代码，避免使用忙等待。\n\n实现线程的优先级调度\n实现线程的优先级捐赠和嵌套优先级捐赠\n实现（补全）线程检查和修改自己优先级的函数\n\n\n实现类似4.4BSD调度器的分级反馈队列调度器(mlfqs)，以优化作业平均响应时间\n\n详细要求请参考：Your Tasks | Pintos\n执行建议执行顺序\n先跑测试，结果应该是 fail 20&#x2F;27。\n\n完成任务1；\n\n涉及修改的文件：devices/timer.c\n测试结果仍然是 fail 20&#x2F;27，但是速度会变快。\n\n\n完成任务2；\n\n涉及修改的文件：threads/synch.c threads/thread.c threads/thread.h\n测试结果为 fail 7&#x2F;27，前18个测试点都通过。\n\n\n完成任务3MLFQS所需的定点实数运算例程；\n\n涉及修改的文件：threads/thread.c threads/thread.h\n不用跑测试，结果不会有变化，编译通过即可。\n\n\n完成任务3。\n\n涉及修改的文件：threads/thread.c threads/thread.h\n测试结果为 All 27 tests passed.\n\n\n\n代码量参考值这是官方给出的参考值，单位是行。由于代码不同，这显然不能代表唯一正确答案。\ndevices/timer.c       |   42 +++++-threads/synch.c       |   88 ++++++++++++-threads/thread.c      |  196 ++++++++++++++++++++++++++----threads/thread.h      |   23 +++4 files changed, 320 insertions(+), 29 deletions(-)\n\n如果你也想测试一下，可以在pintos容器内依次按照以下执行：\n\n安装diffstat：\n  apt updateapt install diffstatdiffstat --version\n\n版本比较：\n  cd ~/pintosgit diff | diffstat\n\n笔者写的代码比官方的标准版本修改多很多，说明笔者代码效率不高。\n需要注意的内容\n耐心调试，有看不懂的不想看的可以问AI，这个项目代码应该大部分主流LLM都熟悉。\n保证全程参与，或者全程不参与：Project 1相对独立，代码内部逻辑联系紧密，所以建议合作时时刻保持跟进代码进度，或者干脆抱队友大腿。\nProject 1 几乎无法一次性完成，所以需要时间分段。一个合理的时间分段方式是按照任务分开，一次性完成一个任务的代码编写和设计文档撰写。\n完成任务3时，会涉及部分修改任务2的代码；请确保不要删除任务2的代码，而是使用关键指示变量thread_mlfqs作为开关控制。\nProject 1 中代码完成的所有内容都不在后面的Project中重复利用。这意味着Project 2是从白板PintOS开始的。\n\n\n回到目录\n","categories":["零基础速通","CS130 操作系统I"],"tags":["0_Start_Learning"]}]